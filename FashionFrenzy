-- This script runs continuously, searching for the game map. When the map is found,
-- it executes a sequence of teleports and clicks. The sequence is instantly halted 
-- if the in-game timer reaches "00:40" or "00:50", immediately resetting the script
-- to search for the next game round.

-- Configuration
local TELEPORT_DELAY = 0.4 -- Time in seconds to wait at each physical target (reduced for lag)
local SEARCH_WAIT_TIME = 2.0 -- Time in seconds to wait between search attempts
local TIMER_STOP_VALUES = {"00:40", "00:50"} -- Values that trigger a sequence stop
local TIMER_START_THRESHOLD = "00:50" -- If the timer is <= this value when starting, abort the sequence

-- Services and Player Setup
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Wait for the character and HumanoidRootPart to be ready
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

-- Global Control Flags
local IsSequenceActive = false -- Is the teleport/click sequence currently running?
local ShouldStop = false       -- Has the timer triggered a stop signal?

-- Define the path components up to the MINIGAME container
local MINIGAME_CONTAINER_COMPONENTS = {
    "Interiors",
    "FashionFrenzy", -- The script handles the UID suffix when searching for this object.
    "Customize",
    "Minigame" -- This is the common parent container
}

--------------------------------------------------------------------------------
-- TIMER MONITOR THREAD
--------------------------------------------------------------------------------

-- Utility function to read the current timer text from the GUI
local function getCurrentTimerText()
    -- Find the timer label relative to the PlayerGui
    local valueLabel = LocalPlayer.PlayerGui:FindFirstChild("FashionFrenzyInGameApp", true)
    
    if valueLabel and valueLabel:IsA("ScreenGui") then
        -- Traverse the remaining path
        valueLabel = valueLabel:FindFirstChild("Body")
            and valueLabel.Body:FindFirstChild("Left")
            and valueLabel.Body.Left:FindFirstChild("Container")
            and valueLabel.Body.Left.Container:FindFirstChild("ValueLabel")
    end

    if valueLabel and valueLabel:IsA("TextLabel") then
        return valueLabel.Text
    end
    return nil
end

local function timerMonitor()
    while true do
        if IsSequenceActive then
            local text = getCurrentTimerText()

            if text then
                -- Check if the current time matches any of the stop values
                for _, stopValue in ipairs(TIMER_STOP_VALUES) do
                    if text == stopValue then
                        if not ShouldStop then
                            print(string.format("!! TIMER HIT STOP VALUE (%s). Stopping sequence and preparing to restart search.", stopValue))
                            ShouldStop = true
                            break
                        end
                    end
                end
            end
        end
        task.wait(0.1) -- Check the timer frequently
    end
end

task.spawn(timerMonitor)

--------------------------------------------------------------------------------
-- GUI INTERACTION FUNCTIONS
--------------------------------------------------------------------------------

-- Function to simulate click events (using getconnections)
local function clickButton(button)
    if ShouldStop then return end -- Check before clicking

    if not button or not getconnections then
        return
    end

    -- print("Button found! Attempting to click:", button.Name) -- Commented out to reduce console spam

    -- MouseButton1Down
    for _, connection in pairs(getconnections(button.MouseButton1Down)) do
        connection:Fire()
    end
    task.wait(0.1)

    -- MouseButton1Click
    for _, connection in pairs(getconnections(button.MouseButton1Click)) do
        connection:Fire()
    end
    task.wait(0.1)

    -- MouseButton1Up
    for _, connection in pairs(getconnections(button.MouseButton1Up)) do
        connection:Fire()
    end
    -- print("Successfully clicked the button!") -- Commented out to reduce console spam
end

-- Clicks a pet button in BackpackApp
local function findAndClickPetButton()
    if ShouldStop then return end

    local gui = LocalPlayer.PlayerGui

    -- Traverse the path: BackpackApp.Frame.Body.ScrollComplex.ScrollingFrame.Content
    local content = gui:FindFirstChild("BackpackApp")
        and gui.BackpackApp:FindFirstChild("Frame")
        and gui.BackpackApp.Frame:FindFirstChild("Body")
        and gui.BackpackApp.Frame.Body:FindFirstChild("ScrollComplex")
        and gui.BackpackApp.Frame.Body.ScrollComplex:FindFirstChild("ScrollingFrame")
        and gui.BackpackApp.Frame.Body.ScrollComplex.ScrollingFrame:FindFirstChild("Content")

    if not content then
        warn("Pet content container not found in BackpackApp.")
        return
    end
    
    local pets = content:FindFirstChild("pets")
    if not pets then warn("'pets' container not found under Content."); return end

    local targetRow = pets:FindFirstChild("Row0")
    if not targetRow then warn("Pet row 'Row0' not found."); return end

    for _, itemFrame in ipairs(targetRow:GetChildren()) do
        if ShouldStop then return end -- Check inside the loop

        if itemFrame.Name:lower():match("add_more_pets") then 
            continue
        end

        local buttonToClick = itemFrame:FindFirstChild("Button", true)
        
        if buttonToClick and (buttonToClick:IsA("TextButton") or buttonToClick:IsA("ImageButton")) then
            clickButton(buttonToClick)
            return -- Clicked the first available pet button and exit
        end
    end
    warn("No usable pet button found inside the first pet row.")
end

-- Clicks the Backpack Exit button
local function closeBackpack()
    if ShouldStop then return end

    local exitButton = LocalPlayer.PlayerGui:FindFirstChild("BackpackApp")
        and LocalPlayer.PlayerGui.BackpackApp:FindFirstChild("Frame")
        and LocalPlayer.PlayerGui.BackpackApp.Frame:FindFirstChild("Header")
        and LocalPlayer.PlayerGui.BackpackApp.Frame.Header:FindFirstChild("ExitButton")

    if exitButton then
        print("Closing Backpack App.")
        clickButton(exitButton)
    else
        warn("Backpack ExitButton not found.")
    end
end

-- Clicks all buttons in the BasicSelects container
local function clickAllBasicSelects()
    if ShouldStop then return end

    local basicSelectsContainer = LocalPlayer.PlayerGui:FindFirstChild("InteractionsApp")
        and LocalPlayer.PlayerGui.InteractionsApp:FindFirstChild("BasicSelects")

    if not basicSelectsContainer then
        warn("InteractionsApp.BasicSelects container not found. Skipping clicks.")
        return
    end

    local clickCount = 0
    -- Clicks the nested TapButton inside each Template frame
    for _, templateFrame in ipairs(basicSelectsContainer:GetChildren()) do
        if ShouldStop then return end -- Check inside the loop
        
        if templateFrame:IsA("GuiObject") then
            local buttonToClick = templateFrame:FindFirstChild("TapButton")

            if buttonToClick and (buttonToClick:IsA("TextButton") or buttonToClick:IsA("ImageButton")) then
                clickButton(buttonToClick)
                clickCount = clickCount + 1
            end
        end
    end
    -- print(string.format("Clicked %d buttons in BasicSelects.", clickCount)) -- Commented out to reduce console spam
end

--------------------------------------------------------------------------------
-- UTILITY & TELEPORT FUNCTIONS
--------------------------------------------------------------------------------

-- Helper function to find a child whose name starts with a specific prefix.
local function findChildByPrefix(parent, prefix)
    for _, child in ipairs(parent:GetChildren()) do
        if child.Name:sub(1, #prefix) == prefix then
            return child
        end
    end
    return nil
end

-- Function to handle the marker creation and teleportation
local function TeleportTo(position)
    if ShouldStop then return end -- Check before teleporting

    -- Create the small target cube (Teleport Marker)
    local marker = Instance.new("Part")
    marker.Name = "TeleportMarker"
    marker.Size = Vector3.new(1.5, 1.5, 1.5)
    marker.Position = position + Vector3.new(0, 3, 0)
    marker.Transparency = 0.2
    marker.Anchored = true
    marker.CanCollide = false
    marker.BrickColor = BrickColor.new("Really red")
    marker.Material = Enum.Material.Neon
    marker.Parent = Workspace

    -- Teleport the character's HumanoidRootPart to the marker's location
    HumanoidRootPart.CFrame = CFrame.new(position + Vector3.new(0, 5, 0))

    -- Wait at the location
    task.wait(TELEPORT_DELAY)

    -- Clean up the marker
    marker:Destroy()
end

-- Function to find the position of the first available Paw part
local function findFirstPawPosition(minigameContainer)
    local petPodiumsContainer = minigameContainer:FindFirstChild("PetPodiums")
    if not petPodiumsContainer then return nil end

    for _, podiumModel in ipairs(petPodiumsContainer:GetChildren()) do
        local part1 = podiumModel:FindFirstChild("1")
        local targetPaw = part1 and part1:FindFirstChild("Paw")

        if targetPaw and targetPaw:IsA("BasePart") then
            return targetPaw.Position
        end
    end
    return nil
end

--------------------------------------------------------------------------------
-- TELEPORT SEQUENCE FUNCTIONS
--------------------------------------------------------------------------------

-- Function to handle Mannequin teleportation and accessory equip cycle
local function teleportToMannequins(minigameContainer, returnPosition)
    print("--- STARTING MANNEQUIN TELEPORT & ACCESSORY CYCLE ---")
    local mannequinsContainer = minigameContainer:FindFirstChild("AccessoryMannequins")

    if not mannequinsContainer or ShouldStop then warn("Mannequin container not found or sequence stopped."); return end

    local targetsFound = 0
    for _, mannequinModel in ipairs(mannequinsContainer:GetChildren()) do
        if ShouldStop then return end -- Stop check
        
        targetsFound = targetsFound + 1
        local targetHRP = mannequinModel:FindFirstChild("HumanoidRootPart")

        if targetHRP and targetHRP:IsA("BasePart") then
            print(string.format("[MANNEQUIN %d] Teleporting to Mannequin: %s", targetsFound, mannequinModel.Name))
            
            -- 1. Teleport to Mannequin HRP
            TeleportTo(targetHRP.Position)
            
            -- 2. Click all buttons in BasicSelects (Accessory Selection)
            clickAllBasicSelects() 
            if ShouldStop then return end
            
            -- 3. Teleport back to Paw position to finalize accessory selection
            if returnPosition then
                TeleportTo(returnPosition) 
                if ShouldStop then return end
                
                -- 4. Click all buttons in BasicSelects again (Confirmation/Put On)
                clickAllBasicSelects() 
                if ShouldStop then return end
            else
                warn("Return position (Paw) not provided. Cannot finalize accessory selection cycle.")
            end
            
        else
            warn(string.format("Mannequin %s does not have a HumanoidRootPart. Skipping.", mannequinModel.Name))
        end
    end
    
    if not ShouldStop then
        print(string.format("--- Mannequin Cycle Finished. Visited %d locations. ---", targetsFound))
    end
end

-- Function to handle Pet Paw teleportation and pet selection cycle
local function teleportToPetPaws(minigameContainer)
    print("--- STARTING PET PODIUM PAW TELEPORT & PET SELECTION CYCLE ---")
    local petPodiumsContainer = minigameContainer:FindFirstChild("PetPodiums")

    if not petPodiumsContainer or ShouldStop then warn("PetPodiums container not found or sequence stopped."); return end

    local targetsFound = 0
    for _, podiumModel in ipairs(petPodiumsContainer:GetChildren()) do
        if ShouldStop then return end -- Stop check
        
        targetsFound = targetsFound + 1
        local part1 = podiumModel:FindFirstChild("1")
        local targetPaw = part1 and part1:FindFirstChild("Paw")

        if targetPaw and targetPaw:IsA("BasePart") then
            print(string.format("[PAW %d] Teleporting to Paw: %s", targetsFound, podiumModel.Name))
            
            -- 1. Teleport to Paw
            TeleportTo(targetPaw.Position)
            if ShouldStop then return end
            
            -- 2. Click pet button in GUI to select a pet
            findAndClickPetButton() 
            if ShouldStop then return end

            -- 3. Close the Backpack App
            closeBackpack()
            if ShouldStop then return end
        else
            warn(string.format("Podium %s does not have a valid Paw part. Skipping.", podiumModel.Name))
        end
    end
    
    if not ShouldStop then
        print(string.format("--- Pet Paw Cycle Finished. Visited %d Paw locations. ---", targetsFound))
    end
end

-- Function containing the main execution logic
local function runFullSequence(minigameContainer)
    local initialTime = getCurrentTimerText()
    
    -- PRE-SEQUENCE TIMER CHECK: If the time is too low (e.g., 00:50 or lower), abort the start.
    if initialTime and (initialTime <= TIMER_START_THRESHOLD) then
        print(string.format("!! Initial timer check failed: %s is <= %s. Round is too late. Resetting search.", initialTime, TIMER_START_THRESHOLD))
        return
    end

    IsSequenceActive = true
    
    -- Initial Teleport to the first Paw and store its position
    local initialPawPosition = findFirstPawPosition(minigameContainer)

    if initialPawPosition and not ShouldStop then
        print("--- Initial Teleport: Moving to the first Pet Paw location. ---")
        TeleportTo(initialPawPosition)
    elseif not ShouldStop then
        warn("Could not find an initial Pet Paw target. Starting full sequence immediately.")
    end

    -- Delay before starting the full sequence
    if not ShouldStop then
        task.wait(TELEPORT_DELAY * 2) -- A slightly longer initial wait
    end

    -- Execute both FULL teleport sequences in order
    if not ShouldStop then
        teleportToMannequins(minigameContainer, initialPawPosition) 
    end
    
    if not ShouldStop then
        teleportToPetPaws(minigameContainer)
    end
    
    -- Final status update
    if not ShouldStop then
        print("--- FULL SEQUENCE COMPLETE. Waiting for timer reset to continue loop. ---")
    else
        print("--- Sequence was interrupted by timer. Resetting to search state. ---")
    end
    
    IsSequenceActive = false
    ShouldStop = false -- Reset stop flag for the next cycle
end


--------------------------------------------------------------------------------
-- MAIN SCRIPT LOOP (CONTINUOUS SEARCH & RESTART)
--------------------------------------------------------------------------------

while true do
    -- Continuous Search Output
    print(string.format("Searching For %s Interior...", MINIGAME_CONTAINER_COMPONENTS[2]))
    
    local minigameContainer = Workspace
    local foundAll = true

    -- Traverse the path to find the common MINIGAME container
    for i, name in ipairs(MINIGAME_CONTAINER_COMPONENTS) do
        if not minigameContainer then break end

        if name == "FashionFrenzy" then
            minigameContainer = findChildByPrefix(minigameContainer, name)
        elseif i == 1 then
            -- Using WaitForChild for the top-level folder
            minigameContainer = minigameContainer:WaitForChild(name, SEARCH_WAIT_TIME) 
        else
            minigameContainer = minigameContainer:FindFirstChild(name)
        end

        if not minigameContainer then
            -- Only warn if it's the target component that couldn't be found
            if i > 1 then warn("Could not find container at path component: " .. name) end
            foundAll = false
            break
        end
    end

    -- If the container is found (implying the game round has started), run the sequence
    if foundAll and minigameContainer then
        print("Minigame container found. Starting full teleport sequence.")
        runFullSequence(minigameContainer)
    end

    -- Wait before attempting to search/restart the cycle again
    task.wait(SEARCH_WAIT_TIME)
end
