--[[
    Roblox Automation Script: Continuous Minigame Sequence

    This script runs continuously, searching for the game map. When the map is found,
    it executes a sequence of teleports and clicks. The sequence is instantly halted
    if the in-game timer reaches "00:10" or "00:20", immediately resetting the script
    to search for the next game round.

    -- Key GUI Targets --
    1. Clicks TapButton elements in InteractionsApp.BasicSelects.
    2. Clicks the dynamically named pet item or a nested button in BackpackApp, 
       explicitly skipping any element named "add_more_pets".

    -- Execution Flow (Strict Start Sequence) --
    1. Teleport to Paw Position (or closest fallback).
    2. Click ALL BasicSelects buttons (Initial Accessory Equip).
    3. Open Backpack, click ALL Pet Buttons, then close Backpack (Initial Pet Equip).
    4. Proceed to Mannequin cycling (timed accessory testing).
]]

-- Configuration
local TELEPORT_DELAY = 0.15 -- Time in seconds to wait at each physical target (reduced for speed)
local SEARCH_WAIT_TIME = 2.0 -- Time in seconds to wait between search attempts
local TIMER_STOP_VALUES = {"00:10", "00:20"} -- Values that trigger a sequence stop
local TIMER_START_THRESHOLD = "00:30" -- If the timer is <= this value when starting, abort the sequence
local MANNEQUIN_TEST_TIME = 5.0 -- Time in seconds to wait at each mannequin for testing (Reduced for speed)

-- The status message configuration (Updated to display version)
local VERSION_TEXT = "V3.3 Active make this scirpt last while the event lasts!" -- The version text to display
local STATUS_DURATION = 5.0 
local STATUS_COLOR = Color3.fromRGB(255, 0, 0) -- Bright Red for high visibility
local RESTORE_COLOR = Color3.fromRGB(255, 255, 255) -- White (Used if original color can't be stored)

-- Services and Player Setup
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Wait for the character and HumanoidRootPart to be ready
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

-- Global Control Flags
local IsSequenceActive = false -- Is the teleport/click sequence currently running?
local ShouldStop = false        -- Has the timer triggered a stop signal?

-- State for prioritization across game rounds
local cycleCount = 0

-- Define the path components up to the MINIGAME container
local MINIGAME_CONTAINER_COMPONENTS = {
    "Interiors",
    "FashionFrenzy", -- The script handles the UID suffix when searching for this object.
    "Customize",
    "Minigame" -- This is the common parent container
}

--------------------------------------------------------------------------------
-- STATUS UI HANDLER (USER-SPECIFIC IMPLEMENTATION)
--------------------------------------------------------------------------------

-- Displays the version status message in red for 3 seconds.
local function displayVersionStatus()
    -- Use robust WaitForChild to ensure the container exists
    local HintAppContainer = LocalPlayer.PlayerGui:WaitForChild("HintApp", 2) 
    local uiElement = HintAppContainer and HintAppContainer:FindFirstChild("LargeTextLabel")

    if uiElement and uiElement:IsA("TextLabel") then
        print(string.format("Displaying version status: '%s' in red for %d seconds.", VERSION_TEXT, STATUS_DURATION))

        -- Store original properties to restore them later
        local originalTextTransparency = uiElement.TextTransparency
        local originalTextColor = uiElement.TextColor3 -- Store the original color of the label
        
        uiElement.Text = VERSION_TEXT
        uiElement.TextTransparency = 0 
        uiElement.TextColor3 = STATUS_COLOR
        
        task.wait(STATUS_DURATION) 
        
        -- Restore state: clear text and restore color and transparency
        uiElement.Text = ""
        uiElement.TextColor3 = originalTextColor -- Restore the original color
        uiElement.TextTransparency = originalTextTransparency
    else
        warn("Could not find PlayerGui.HintApp.LargeTextLabel. Skipping status display.")
    end
end

--------------------------------------------------------------------------------
-- TIMER MONITOR THREAD
--------------------------------------------------------------------------------

-- Utility function to read the current timer text from the GUI
local function getCurrentTimerText()
    -- Find the timer label relative to the PlayerGui
    local valueLabel = LocalPlayer.PlayerGui:FindFirstChild("FashionFrenzyInGameApp", true)
    
    if valueLabel and valueLabel:IsA("ScreenGui") then
        -- Traverse the remaining path
        valueLabel = valueLabel:FindFirstChild("Body")
            and valueLabel.Body:FindFirstChild("Left")
            and valueLabel.Body.Left:FindFirstChild("Container")
            and valueLabel.Body.Left.Container:FindFirstChild("ValueLabel")
    end

    if valueLabel and valueLabel:IsA("TextLabel") then
        return valueLabel.Text
    end
    return nil
end

-- Function to safely wait for a duration while checking the global stop flag
local function waitWithStopCheck(duration)
    local checkInterval = 1 -- Check every 1 second
    local remaining = duration
    
    while remaining > 0 and not ShouldStop do
        local waitTime = math.min(checkInterval, remaining)
        task.wait(waitTime)
        remaining = remaining - checkInterval
    end
end

local function timerMonitor()
    while true do
        if IsSequenceActive then
            local text = getCurrentTimerText()

            if text then
                -- Check if the current time matches any of the stop values
                for _, stopValue in ipairs(TIMER_STOP_VALUES) do
                    if text == stopValue then
                        if not ShouldStop then
                            print(string.format("!! TIMER HIT STOP VALUE (%s). Stopping sequence and preparing to restart search.", stopValue))
                            ShouldStop = true
                            break
                        end
                    end
                end
            end
        end
        task.wait(0.1) -- Check the timer frequently
    end
end

task.spawn(timerMonitor)

-- IMPORTANT FIX: Call the version display function immediately after setup
-- This ensures the version number is displayed when the script loads,
-- regardless of whether the main automation sequence starts.
displayVersionStatus()

--------------------------------------------------------------------------------
-- GUI INTERACTION FUNCTIONS (Integrated Click Logic)
--------------------------------------------------------------------------------

-- Function to simulate click events using the most reliable getconnections method.
-- This follows the specific time sequence requested (wait(0.1) between fires).
local function clickButton(button)
    if ShouldStop then return end -- Check before clicking

    if not button or not getconnections then
        return
    end
    
    -- Crucial check to ensure the button is visible and active before trying to click
    if button:IsA("GuiObject") and (button.Visible == false or button.Active == false) then
        warn(string.format("Button %s is not Visible or Active. Skipping click attempts.", button.Name))
        return
    end

    print("Attempting to click:", button.Name, "(Type:", button.ClassName, ")")
    
    -- 1. Attempt to simulate MouseButton1Down
    for _, connection in pairs(getconnections(button.MouseButton1Down)) do
        connection:Fire()
    end
    task.wait(0.1) -- Time sequence delay

    -- 2. Attempt to simulate MouseButton1Click
    for _, connection in pairs(getconnections(button.MouseButton1Click)) do
        connection:Fire()
    end
    task.wait(0.1) -- Time sequence delay

    -- 3. Attempt to simulate MouseButton1Up
    for _, connection in pairs(getconnections(button.MouseButton1Up)) do
        connection:Fire()
    end
    
    -- EXPLICIT CLICK CONFIRMATION
    print("Successfully fired events for:", button.Name)
end

-- Helper function to open the main Inventory/Backpack UI before finding the pet
local function openMainInventory()
    if ShouldStop then return end
    -- Common names for the main backpack button in the PlayerGui
    local button = LocalPlayer.PlayerGui:FindFirstChild("InventoryButton", true)
    if not button then
        button = LocalPlayer.PlayerGui:FindFirstChild("BackpackButton", true)
    end
    
    if button and button:IsA("GuiObject") then
        print("Explicitly clicking the main Inventory/Backpack UI button.")
        clickButton(button)
        -- Give UI a moment to start loading the BackpackApp
        task.wait(0.2)
    else
        warn("Could not find the main Backpack/Inventory UI button. Skipping explicit open.")
    end
end

-- Clicks all available pet buttons in BackpackApp by prioritizing the dynamic item frame itself.
local function findAndClickPetButton()
    if ShouldStop then return end

    local gui = LocalPlayer.PlayerGui
    local BackpackApp = nil
    -- INCREASED TIMEOUT: Allows more time for the UI to load before giving up on this cycle.
    local waitTimeout = 5 -- Wait up to 5 seconds for the UI to appear
    local startTime = tick()

    -- 1. WAIT for the main BackpackApp GUI to appear after clicking the inventory button
    repeat
        BackpackApp = gui:FindFirstChild("BackpackApp")
        if not BackpackApp then
            task.wait(0.1)
        end
    until BackpackApp or ShouldStop or (tick() - startTime > waitTimeout)

    if not BackpackApp then
        warn(string.format("BackpackApp GUI failed to open or load within %d seconds. Skipping pet selection this cycle.", waitTimeout))
        return -- Returns gracefully, allowing the main script loop to continue and try again later.
    end
    
    -- 2. Traverse the path using the found BackpackApp
    local content = BackpackApp:FindFirstChild("Frame")
        and BackpackApp.Frame:FindFirstChild("Body")
        and BackpackApp.Frame.Body:FindFirstChild("ScrollComplex")
        and BackpackApp.Frame.Body.ScrollComplex:FindFirstChild("ScrollingFrame")
        and BackpackApp.Frame.Body.ScrollComplex.ScrollingFrame:FindFirstChild("Content")

    if not content then
        warn("Pet content container not fully loaded in BackpackApp structure. Skipping pet selection this cycle.")
        return -- Returns gracefully
    end
    
    local pets = content:FindFirstChild("pets")
    if not pets then warn("'pets' container not found under Content. Skipping pet selection this cycle."); return end

    print("Searching for ALL usable pet buttons, prioritizing the dynamically named item frame itself...")
    
    local foundPetButton = false
    
    -- Iterate through all children of 'pets' (which should be the rows or direct pet containers)
    for _, rowOrContainer in ipairs(pets:GetChildren()) do
        if ShouldStop then return end -- Check for sequence stop
        
        -- Explicitly check and skip any container related to "add_more_pets"
        if rowOrContainer.Name:lower():match("add_more_pets") then 
            print(string.format("Skipping excluded container: %s", rowOrContainer.Name))
            continue -- Skip the entire container
        end
        
        -- Priority 1: Check if the container itself holds the button
        local buttonToClick = rowOrContainer:FindFirstChild("Button", true) or rowOrContainer:FindFirstChild("TapButton", true)

        if buttonToClick and (buttonToClick:IsA("TextButton") or buttonToClick:IsA("ImageButton")) then
            print(string.format("Found and clicking pet button in top-level container: %s", rowOrContainer.Name))
            clickButton(buttonToClick)
            foundPetButton = true
        else
            -- Priority 2: Iterate through children of the row/container (the individual pet item frames, e.g., "2_1e892...")
            for _, itemFrame in ipairs(rowOrContainer:GetChildren()) do
                if ShouldStop then return end -- Check for sequence stop
                
                -- Explicitly check and skip any item frame related to "add_more_pets"
                if itemFrame.Name:lower():match("add_more_pets") then 
                    print(string.format("Skipping excluded item frame: %s", itemFrame.Name))
                    continue
                end

                local targetElement = nil
                
                -- ATTEMPT 1 (P1): Check if the itemFrame (the dynamically named part) is the clickable object itself.
                if itemFrame:IsA("TextButton") or itemFrame:IsA("ImageButton") then
                    targetElement = itemFrame
                    print(string.format("P1 Click: Targeting dynamic item frame itself: %s", itemFrame.Name))
                end

                -- ATTEMPT 2 (P2): Fallback: If not, look for a nested Button/TapButton inside the frame.
                if not targetElement then
                    targetElement = itemFrame:FindFirstChild("Button", true) or itemFrame:FindFirstChild("TapButton", true)
                    if targetElement then
                        print(string.format("P2 Fallback: Targeting nested button in: %s -> %s", rowOrContainer.Name, itemFrame.Name))
                    end
                end
                
                -- Execute the click if we found a valid button target.
                if targetElement and (targetElement:IsA("TextButton") or targetElement:IsA("ImageButton")) then
                    clickButton(targetElement)
                    foundPetButton = true
                end
            end
        end
    end

    if not foundPetButton then
        warn("No usable pet buttons found inside the 'pets' container after deep search.")
    else
        print("Finished clicking all available pet buttons in the BackpackApp.")
    end
end


-- Clicks the Backpack Exit button
local function closeBackpack()
    if ShouldStop then return end

    local exitButton = LocalPlayer.PlayerGui:FindFirstChild("BackpackApp")
        and LocalPlayer.PlayerGui.BackpackApp:FindFirstChild("Frame")
        and LocalPlayer.PlayerGui.BackpackApp.Frame:FindFirstChild("Header")
        and LocalPlayer.PlayerGui.BackpackApp.Frame.Header:FindFirstChild("ExitButton")

    if exitButton then
        print("Closing Backpack App.")
        clickButton(exitButton)
    else
        warn("Backpack ExitButton not found.")
    end
end

-- Clicks all buttons in the BasicSelects container
local function clickAllBasicSelects()
    if ShouldStop then return end

    local basicSelectsContainer = LocalPlayer.PlayerGui:FindFirstChild("InteractionsApp")
        and LocalPlayer.PlayerGui.InteractionsApp:FindFirstChild("BasicSelects")

    if not basicSelectsContainer then
        warn("InteractionsApp.BasicSelects container not found. Skipping clicks.")
        return
    end

    local clickCount = 0
    -- Clicks the nested TapButton inside each Template frame
    for _, templateFrame in ipairs(basicSelectsContainer:GetChildren()) do
        if ShouldStop then return end -- Check inside the loop
        
        if templateFrame:IsA("GuiObject") then
            -- Use the recursive FindFirstChild(name, true) to search deeply
            -- inside the templateFrame for the TapButton, handling nested frames.
            local buttonToClick = templateFrame:FindFirstChild("TapButton", true) 

            if buttonToClick and (buttonToClick:IsA("TextButton") or buttonToClick:IsA("ImageButton")) then
                clickButton(buttonToClick)
                clickCount = clickCount + 1
                -- Clicks are instantaneous for max aggressiveness
            end
        end
    end
    print(string.format("Clicked %d BasicSelect buttons.", clickCount))
end

--------------------------------------------------------------------------------
-- UTILITY & TELEPORT FUNCTIONS
--------------------------------------------------------------------------------

-- Helper function to find a child whose name starts with a specific prefix.
local function findChildByPrefix(parent, prefix)
    for _, child in ipairs(parent:GetChildren()) do
        if child.Name:sub(1, #prefix) == prefix then
            return child
        end
    end
    return nil
end

-- Function to find the best physical part to teleport to within a model.
-- This prioritizes a specific part name (like HRP, Paw, or Head) but falls back to any BasePart.
local function findBestPartToTeleportTo(model, primaryName)
    -- 1. Check for the primary part (e.g., Head, Paw) recursively
    local primaryPart = model:FindFirstChild(primaryName, true)
    if primaryPart and primaryPart:IsA("BasePart") then
        return primaryPart
    end

    -- 2. Check if the model itself is a part
    if model:IsA("BasePart") then
        return model
    end

    -- 3. Fallback: Find the first BasePart (or MeshPart, Part, etc.) recursively
    for _, descendant in ipairs(model:GetDescendants()) do
        if descendant:IsA("BasePart") then
            -- Ensure we don't accidentally fall back to HumanoidRootPart if it exists and wasn't the primary search
            if primaryName ~= "HumanoidRootPart" and descendant.Name == "HumanoidRootPart" then
                continue 
            end
            return descendant
        end
    end

    return nil
end

-- Function to handle the marker creation and teleportation
local function TeleportTo(position)
    if ShouldStop then return end -- Check before teleporting

    -- Create the small target cube (Teleport Marker)
    local marker = Instance.new("Part")
    marker.Name = "TeleportMarker"
    marker.Size = Vector3.new(1.5, 1.5, 1.5)
    marker.Position = position + Vector3.new(0, 3, 0)
    marker.Transparency = 0.2
    marker.Anchored = true
    marker.CanCollide = false
    marker.BrickColor = BrickColor.new("Really red")
    marker.Material = Enum.Material.Neon
    marker.Parent = Workspace

    -- Teleport the character's HumanoidRootPart to the marker's location
    HumanoidRootPart.CFrame = CFrame.new(position + Vector3.new(0, 5, 0))

    -- Wait at the location
    task.wait(TELEPORT_DELAY)

    -- Clean up the marker
    marker:Destroy()
end

-- Function to find the position of the first available Paw part (now uses robust finding)
local function findFirstPawPosition(minigameContainer)
    local petPodiumsContainer = minigameContainer:FindFirstChild("PetPodiums")
    if not petPodiumsContainer then return nil end

    for _, podiumModel in ipairs(petPodiumsContainer:GetChildren()) do
        -- Use the robust search on the podium model, prioritizing "Paw"
        local targetPart = findBestPartToTeleportTo(podiumModel, "Paw")

        if targetPart then
            return targetPart.Position
        end
    end
    return nil
end

-- Function to find the position of the first Mannequin (used for fallback teleport)
local function findFirstMannequinPosition(minigameContainer)
    local mannequinsContainer = minigameContainer:FindFirstChild("AccessoryMannequins")
    if not mannequinsContainer then return nil end

    for _, mannequinModel in ipairs(mannequinsContainer:GetChildren()) do
        -- Prioritize "Head" as the teleport target
        local targetPart = findBestPartToTeleportTo(mannequinModel, "Head")
        
        if targetPart then
            return targetPart.Position
        end
    end
    return nil
end


--------------------------------------------------------------------------------
-- TELEPORT SEQUENCE FUNCTIONS
--------------------------------------------------------------------------------

-- Function to handle Mannequin teleportation and accessory equip cycle (The "others" step)
local function teleportToMannequins(minigameContainer, returnPosition)
    print("--- STARTING MANNEQUIN TELEPORT & ACCESSORY CYCLE ---")
    local mannequinsContainer = minigameContainer:FindFirstChild("AccessoryMannequins")

    if not mannequinsContainer or ShouldStop then warn("Mannequin container not found or sequence stopped."); return end

    local targetsFound = 0
    for _, mannequinModel in ipairs(mannequinsContainer:GetChildren()) do
        if ShouldStop then return end -- Stop check
        
        targetsFound = targetsFound + 1
        -- Prioritize "Head" as the teleport target
        local targetPart = findBestPartToTeleportTo(mannequinModel, "Head") 

        if targetPart then
            print(string.format("[MANNEQUIN %d] Teleporting to Mannequin: %s (Target: %s)", targetsFound, mannequinModel.Name, targetPart.Name))
            
            -- 1. Teleport to Mannequin HRP/Part
            TeleportTo(targetPart.Position)
            
            -- 2. Click all buttons in BasicSelects (Accessory Selection)
            clickAllBasicSelects() 
            if ShouldStop then return end
            
            -- 3. Wait 5 seconds (safe wait with timer check)
            print(string.format("[MANNEQUIN %d] Waiting %d seconds for accessory testing...", targetsFound, MANNEQUIN_TEST_TIME))
            waitWithStopCheck(MANNEQUIN_TEST_TIME)
            if ShouldStop then return end
            
            -- 4. Teleport back to Paw position to finalize accessory selection
            if returnPosition then
                print(string.format("[MANNEQUIN %d] Confirmation Step: Teleporting back to return position for finalize click.", targetsFound))
                
                TeleportTo(returnPosition) 
                if ShouldStop then return end
                
                -- ADDED STABILIZATION DELAY to allow the UI to refresh/re-activate
                task.wait(0.2) 
                
                -- 5. Click all buttons in BasicSelects again (Confirmation/Put On) with RETRY
                print(string.format("[MANNEQUIN %d] Confirmation Step: Clicking BasicSelects again (3 attempts) to confirm accessory.", targetsFound))
                
                -- *** ADDED RETRY LOOP HERE ***
                for attempt = 1, 3 do
                    clickAllBasicSelects() 
                    task.wait(0.1) -- Short wait between retries
                end
                
                if ShouldStop then return end
            else
                -- Log a specific warning about the skipped steps
                warn(string.format("[MANNEQUIN %d] Return position (Paw/Fallback) was nil. Skipping accessory confirmation clicks (Steps 4 & 5).", targetsFound))
            end
            
        else
            warn(string.format("Mannequin %s does not have a suitable part (Head or BasePart) for teleporting. Skipping.", mannequinModel.Name))
        end
    end
    
    if not ShouldStop then
        print(string.format("--- Mannequin Cycle Finished. Visited %d locations. ---", targetsFound))
    end
end

-- Function containing the main execution logic
local function runFullSequence(minigameContainer)
    local initialTime = getCurrentTimerText()
    
    -- PRE-SEQUENCE TIMER CHECK: If the time is too low (e.g., 00:30 or lower), abort the start.
    if initialTime and (initialTime <= TIMER_START_THRESHOLD) then
        print(string.format("!! Initial timer check failed: %s is <= %s. Round is too late. Resetting search.", initialTime, TIMER_START_THRESHOLD))
        return
    end

    -- Increment the cycle count for this attempt
    cycleCount = cycleCount + 1

    print(string.format("--- Starting Full Sequence (Cycle #%d). ---", cycleCount))

    IsSequenceActive = true
    
    -- REMOVED: displayVersionStatus() call moved to the main thread startup.

    -- 1. Determine the Paw position (This is the critical return point for accessory confirmation).
    local pawPosition = findFirstPawPosition(minigameContainer)
    local returnPositionForMannequins = pawPosition -- Use pawPosition as the primary return point

    -- FALLBACK check: If Paw is missing, find a Mannequin to use for the initial setup teleport.
    if not pawPosition then
        -- If Paw is missing, we use the first Mannequin as the initial equip point.
        local firstMannequinPosition = findFirstMannequinPosition(minigameContainer)
        
        if firstMannequinPosition then
            print("!! WARNING: Paw position not found. Initial setup will be performed at the first Mannequin.")
            -- Temporarily set pawPosition to the mannequin for the initial setup block to run.
            pawPosition = firstMannequinPosition 
        else
            warn("!! CRITICAL: Neither Paw nor Mannequin found. Skipping initial setup.")
        end
    end
    
    -- ----------------------------------------------------
    -- INITIAL SETUP SEQUENCE (PAW -> ACCESSORIES -> PETS)
    -- This block enforces the user's required starting order.
    -- ----------------------------------------------------
    if pawPosition and not ShouldStop then
        print("--- START OF ROUND SETUP: Executing strict start sequence (Paw -> Accessories -> Pets). ---")
        
        -- 1. Teleport to Paw (or Mannequin fallback)
        TeleportTo(pawPosition)
        if ShouldStop then return end
        
        -- 2. Click all BasicSelects buttons (initial accessory equip)
        print("--- SETUP: Clicking all BasicSelects buttons (Accessories). ---")
        clickAllBasicSelects() 
        if ShouldStop then return end
        
        -- 3. Open the Backpack and then select all pets
        print("--- SETUP: Opening backpack, selecting ALL pets, and closing. ---")
        openMainInventory() 
        if ShouldStop then return end
        findAndClickPetButton()
        if ShouldStop then return end
        closeBackpack()
        if ShouldStop then return end
        
        print("--- SETUP COMPLETE. Proceeding to Mannequin cycles (The 'others'). ---")
    else
        warn("!! CRITICAL: Paw position not found, and initial setup was skipped.")
    end
    
    -- Delay before starting the timed cycles
    if not ShouldStop then
        task.wait(TELEPORT_DELAY) -- Shortened wait time for speed
    end
    -- ----------------------------------------------------
    -- END INITIAL SETUP SEQUENCE
    -- ----------------------------------------------------
    
    -- 4. Execute Mannequin sequence (The "others")
    if not ShouldStop then
        -- This variable holds the position for the return teleport
        teleportToMannequins(minigameContainer, returnPositionForMannequins) 
    end
    
    -- Final status update
    if not ShouldStop then
        print("--- FULL SEQUENCE COMPLETE. Waiting for timer reset to continue loop. ---")
    else
        print("--- Sequence was interrupted by timer. Resetting to search state. ---")
    end
    
    IsSequenceActive = false
    ShouldStop = false -- Reset stop flag for the next cycle
end


--------------------------------------------------------------------------------
-- MAIN SCRIPT LOOP (CONTINUOUS SEARCH & RESTART)
--------------------------------------------------------------------------------

while true do
    -- Continuous Search Output
    print(string.format("Searching For %s Interior...", MINIGAME_CONTAINER_COMPONENTS[2]))
    
    local minigameContainer = Workspace
    local foundAll = true

    -- Traverse the path to find the common MINIGAME container
    for i, name in ipairs(MINIGAME_CONTAINER_COMPONENTS) do
        if not minigameContainer then break end

        if name == "FashionFrenzy" then
            minigameContainer = findChildByPrefix(minigameContainer, name)
        elseif i == 1 then
            -- Using WaitForChild for the top-level folder
            minigameContainer = minigameContainer:WaitForChild(name, SEARCH_WAIT_TIME) 
        else
            minigameContainer = minigameContainer:FindFirstChild(name)
        end

        if not minigameContainer then
            -- Only warn if it's the target component that couldn't be found
            if i > 1 then warn("Could not find container at path component: " .. name) end
            foundAll = false
            break
        end
    end

    -- If the container is found (implying the game round has started), run the sequence
    if foundAll and minigameContainer then
        print("Minigame container found. Starting full teleport sequence.")
        runFullSequence(minigameContainer)
    end

    -- Wait before attempting to search/restart the cycle again
    task.wait(SEARCH_WAIT_TIME)
end
