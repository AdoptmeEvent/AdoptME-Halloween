
--[[
 	Roblox Minigame Exit Trigger Script

 	This script loads the specified minigame client module and calls key 
 	functions ('exit_minigame', 'player_selected_door', 'escaped', and 'player_selected_door_msg')
 	with mock data, simulating the flow of the minigame.

 	*** FIX APPLIED: Refactored function lookups and injected the 'player_selected_door'
 	               function into the mock context for 'player_selected_door_msg' to resolve 
 	               the "attempt to call missing method" error. The 'get_room' mock 
                   is also simplified to ensure it always returns a non-nil room object. ***
 	
 	WARNING: Calling internal game functions directly can lead to unexpected 
 	behavior or errors if the surrounding environment (like required upvalues 
 	or global states) is not correctly initialized. This is intended for 
 	testing or development purposes only.
--]]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

-- Define the module path components
local MODULE_PATH_COMPONENTS = {
 	"SharedModules",
 	"ContentPacks",
 	"Halloween2025",
 	"Minigames",
 	"HauntletMinigameClient"
}

-- == 1. Helper Functions ==

-- Helper function to recursively find a function by name in a table
local function findFunctionRecursively(t, funcName, visited)
 	visited = visited or {}
 	
 	if visited[t] then return nil end
 	visited[t] = true
 	
 	for key, value in pairs(t) do
 	 	-- 1. Check if the value is the target function (by string representation)
 	 	-- or if the key is the function name
 	 	if (type(value) == "function" and tostring(value):find(funcName)) or 
 	 	   (key == funcName and type(value) == "function") then
 	 	 	return value
 	 	end

 	 	-- 2. Recurse only if the value is a table that hasn't been visited.
 	 	if type(value) == "table" and value ~= t then
 	 	 	-- Safely check if the table can be iterated (not an instance or protected table)
 	 	 	local pcallSuccess, iterResult = pcall(function()
 	 	 	 	for _, _ in pairs(value) do end
 	 	 	 	return true
 	 	 	end)

 	 	 	if pcallSuccess and iterResult then
 	 	 	 	local foundFunc = findFunctionRecursively(value, funcName, visited)
 	 	 	 	if foundFunc then
 	 	 	 	 	return foundFunc
 	 	 	 	end
 	 	 	end
 	 	end
 	end
 	return nil
end

local function getModuleInstance(pathComponents)
 	local currentInstance = ReplicatedStorage
 	for _, name in ipairs(pathComponents) do
 	 	local child = currentInstance:WaitForChild(name, 5)
 	 	if child then
 	 	 	currentInstance = child
 	 	else
 	 	 	warn("Could not find part of the module path: '" .. name .. "'")
 	 	 	return nil
 	 	end
 	end
 	return currentInstance
end

-- == 2. Core Mock Setup (Reused across functions) ==

-- Mock TextLabel object to simulate the GUI element being updated
local mockTextLabel = {
 	Text = "0", -- Start with 0 so tonumber() works
 	Name = "TextLabel",
}

-- Mock the workspace.Interiors object
local mockInteriors = {
 	GetChildren = function()
 	 	print("MOCK: workspace.Interiors:GetChildren() called.")
 	 	return {} -- Return an empty table of children
 	end,
 	FindFirstChild = function(name)
 	 	if name == "HauntletInterior" then
 	 	 	-- Mock the room container found within Interiors
 	 	 	return { 
 	 	 	 	GetChildren = function() return {} end,
 	 	 	 	DoorCounters = {
 	 	 	 	 	FindFirstChild = function(counterID)
 	 	 	 	 	 	print("MOCK: DoorCounters:FindFirstChild() called for counter " .. tostring(counterID))
 	 	 	 	 	 	return {
 	 	 	 	 	 	 	PrimaryPart = {
 	 	 	 	 	 	 	 	SurfaceGui = {
 	 	 	 	 	 	 	 	 	TextLabel = mockTextLabel -- Return the mock TextLabel
 	 	 	 	 	 	 	 	}
 	 	 	 	 	 	 	}
 	 	 	 	 	 	}
 	 	 	 	 	end
 	 	 	 	}
 	 	 	} 
 	 	end
 	 	return nil
 	end,
}

-- Set up Workspace mock once
if Workspace.Interiors == nil then
    Workspace.Interiors = mockInteriors
    print("MOCK: Injected mock 'workspace.Interiors' object.")
end

-- == 3. Trigger Functions ==

-- Function to trigger the player_selected_door_msg logic (NEW)
local function triggerPlayerSelectedDoorMsg(player_selected_door_msg_func, player_selected_door_func)
 	if not player_selected_door_msg_func or type(player_selected_door_msg_func) ~= "function" then
 	 	warn("Cannot trigger 'player_selected_door_msg': Function reference is invalid.")
 	 	return
 	end

 	print("\n--- Triggering player_selected_door_msg (Msg version) ---")
    
    -- Reset mock text label for fresh test
    mockTextLabel.Text = "0"
 	
 	-- Mock arg1: This is the context argument
 	local mock_arg1 = {
 	 	undecided_players_left = 5, -- Initial mock value
 	 	
 	 	-- CRITICAL FIX: Inject the actual function so the wrapper can call it as a method (arg1:player_selected_door)
 	 	player_selected_door = player_selected_door_func, 
 	 	
 	 	-- FIX: Add the new mock function 'await_interior'
 	 	await_interior = function(self, callback)
 	 	 	print("MOCK: arg1:await_interior() called. Immediately running callback...")
 	 	 	if type(callback) == "function" then
 	 	 	 	-- Running the callback simulates the interior loading being complete.
 	 	 	 	callback() 
 	 	 	end
 	 	end,

 	 	-- Mocks for player_selected_door's internal checks
 	 	get_room = function(self, roomID) 
 	 	 	print("MOCK: arg1:get_room() called for room " .. tostring(roomID) .. ". Returning HauntletInterior mock.")
 	 	 	-- FIX: Ensure this always returns the non-nil mock object to prevent indexing nil error
 	 	 	return mockInteriors:FindFirstChild("HauntletInterior")
 	 	end,
 	}

 	-- arg2, arg3, arg4 are passed through to the inner function
 	local mock_arg2 = "HauntletInterior" 
 	local mock_arg3 = "Door1" 
 	local mock_arg4 = 3 -- Target undecided_players_left count 

 	local callSuccess, callResult = pcall(player_selected_door_msg_func, mock_arg1, mock_arg2, mock_arg3, mock_arg4)
 	
 	if callSuccess then
 	 	print("Function 'player_selected_door_msg' finished successfully.")
 	 	print("MOCK: Final undecided_players_left: " .. tostring(mock_arg1.undecided_players_left)) 
 	 	print("MOCK: Final TextLabel.Text: " .. tostring(mockTextLabel.Text)) 
 	else
 	 	warn("Function 'player_selected_door_msg' call failed. Error: " .. tostring(callResult))
 	end
end

-- Function to trigger the player_selected_door logic (original, for comparison)
local function triggerPlayerSelectedDoor(player_selected_door_func)
 	if not player_selected_door_func or type(player_selected_door_func) ~= "function" then
 	 	warn("Cannot trigger 'player_selected_door': Function reference is invalid.")
 	 	return
 	end

 	print("\n--- Triggering player_selected_door (Direct version) ---")
    
    -- Reset mock text label for fresh test
    mockTextLabel.Text = "0"

 	-- Mock arg1: This is the context argument
 	local mock_arg1 = {
 	 	undecided_players_left = 5, 
 	 	is_local_player_escaped = false, 
 	 	round = 0, 
 	 	
 	 	get_room = function(self, roomID)
 	 	 	print("MOCK: arg1:get_room() called for room " .. tostring(roomID) .. ". Returning HauntletInterior mock.")
 	 	 	-- FIX: Ensure this always returns the non-nil mock object to prevent indexing nil error
 	 	 	return mockInteriors:FindFirstChild("HauntletInterior")
 	 	end,
 	 	announce_promise_queue = { cancel = function() end },
 	 	music_stems = {},
 	 	fade_out_stem = function() return { andThen = function(cb) cb() end } end,
 	}

 	local mock_arg2 = "HauntletInterior"
 	local mock_arg3 = "Door1"
 	local mock_arg4 = 4 

 	local callSuccess, callResult = pcall(player_selected_door_func, mock_arg1, mock_arg2, mock_arg3, mock_arg4)
 	
 	if callSuccess then
 	 	print("Function 'player_selected_door' finished successfully.")
 	 	print("MOCK: Final undecided_players_left: " .. tostring(mock_arg1.undecided_players_left))
 	 	print("MOCK: Final TextLabel.Text: " .. tostring(mockTextLabel.Text))
 	else
 	 	warn("Function 'player_selected_door' call failed. Error: " .. tostring(callResult))
 	end
end

-- Function to trigger the escaped logic 
local function triggerEscaped(escaped_func)
 	if not escaped_func or type(escaped_func) ~= "function" then
 	 	warn("Cannot trigger 'escaped': Function reference is invalid.")
 	 	return
 	end

 	print("\n--- Triggering escaped ---")
 	
 	local mock_StatApp = {
 	 	update_stat = function(player, statName, value)
 	 	 	print(string.format("MOCK: StatApp:update_stat() called for player %s, stat: %s, value: %d", 
 	 	 	 	tostring(player.Name), tostring(statName), value))
 	 	end
 	}

 	local mock_LocalPlayer = {
 	 	Name = "LocalPlayerMock",
 	 	UserId = 1000000,
 	}

 	-- The escaped function only takes arg1, which is the context object.
 	local mock_arg1 = {
 	 	static_minigame_id = "Hauntlet", 
 	 	join_zone_destination_id = "MainDoor",
 	 	
 	 	is_local_player_escaped = false, 
 	 	RewardMultiplier = 2, -- Set to max (2)
 	 	Escapes = 100, -- Set to max (100)
 	 	Score = 100, -- Set to max (100)	 	 	
 	 	ExitReward = 100,  
 	 	round = 1, -- Set to 1
 	 	
 	 	StatApp = mock_StatApp,
 	 	LocalPlayer = mock_LocalPlayer,
        
        announce = function(self, message, duration)
            print(string.format("MOCK: arg1:announce() called with message: '%s'", tostring(message)))
        end,
 	}
 	
 	local callSuccess, callResult = pcall(escaped_func, mock_arg1)
 	
 	if callSuccess then
 	 	print("Function 'escaped' call finished successfully.")
 	else
 	 	warn("Function 'escaped' call failed. Error: " .. tostring(callResult))
 	end
end

-- Function to trigger the minigame exit logic 
local function triggerExitMinigame(exit_minigame_func, ClientModule)
 	if not exit_minigame_func or type(exit_minigame_func) ~= "function" then
 	 	warn("Cannot trigger 'exit_minigame': Function reference is invalid.")
 	 	return
 	end

 	print("\n--- Triggering exit_minigame ---")
 	
 	-- Mock arg2: Controls the destination based on minigame result + Rooms cleanup
 	local mock_arg2 = {
 	 	results = { 
 	 	 	[1] = { value = 100 } -- Triggers teleport to HauntletEscape
 	 	},
 	 	Rooms = {
 	 	 	ClearAllChildren = function() 
 	 	 	 	print("MOCK: arg2.Rooms:ClearAllChildren() called.")
 	 	 	end
 	 	}
 	}

 	-- Mock arg1: Contains context data for the minigame + Music cleanup
 	local mock_arg1 = {
 	 	static_minigame_id = "Hauntlet", 
 	 	join_zone_destination_id = "MainDoor",
 	 	
 	 	announce_promise_queue = {
 	 	 	cancel = function()
 	 	 	 	print("MOCK: arg1.announce_promise_queue:cancel() called.")
 	 	 	end
 	 	},
 	 	
 	 	music_stems = {
 	 	 	{ sound = { Destroy = function() print("MOCK: Music stem 1 sound destroyed.") end } },
 	 	 	{ sound = { Destroy = function() print("MOCK: Music stem 2 sound destroyed.") end } },
 	 	},

 	 	fade_out_stem = function(stemId, duration) 
 	 	 	print("MOCK: arg1:fade_out_stem() called for stem " .. tostring(stemId) .. ".")
 	 	 	return {
 	 	 	 	andThen = function(callback) 
 	 	 	 	 	callback()
 	 	 	 	end
 	 	 	}
 	 	end,
 	}

 	local callSuccess, callResult = pcall(exit_minigame_func, ClientModule, mock_arg1, mock_arg2)
 	
 	if callSuccess then
 	 	print("Function 'exit_minigame' call finished successfully.")
 	else
 	 	warn("Function 'exit_minigame' call failed. Error: " .. tostring(callResult))
 	end
end

-- Main execution flow
local function main()
 	local ModuleInstance = getModuleInstance(MODULE_PATH_COMPONENTS)

 	if not ModuleInstance or not ModuleInstance:IsA("ModuleScript") then
 	 	warn("Failed to locate or verify the ModuleScript instance.")
 	 	return
 	end

 	print("Successfully located ModuleScript. Attempting to require...")
 	
 	local success, ClientModule = pcall(require, ModuleInstance)

 	if not success or type(ClientModule) ~= "table" then
 	 	warn("Failed to require the module or it did not return a table. Error: " .. tostring(ClientModule))
 	 	return
 	end
 	
    -- Function Lookup (Handle cases where functions are not at the top level)
    print("Searching for functions...")
    local player_selected_door_msg_func = ClientModule.player_selected_door_msg or findFunctionRecursively(ClientModule, "player_selected_door_msg")
    local player_selected_door_func = ClientModule.player_selected_door or findFunctionRecursively(ClientModule, "player_selected_door")
    local escaped_func = ClientModule.escaped or findFunctionRecursively(ClientModule, "escaped")
    local exit_minigame_func = ClientModule.exit_minigame or findFunctionRecursively(ClientModule, "exit_minigame")
    
    -- Check if all critical functions were found
    if not player_selected_door_msg_func or not player_selected_door_func or not escaped_func or not exit_minigame_func then
        warn("One or more critical minigame functions could not be located in the module.")
    end

    -- 1. Execute the message-passing door selection logic
 	triggerPlayerSelectedDoorMsg(player_selected_door_msg_func, player_selected_door_func)

    -- 2. Execute the direct player selection logic (for comparison)
 	triggerPlayerSelectedDoor(player_selected_door_func)

 	-- 3. Execute the escaped logic
 	triggerEscaped(escaped_func)

 	-- 4. Execute the minigame exit logic
 	triggerExitMinigame(exit_minigame_func, ClientModule)
end

main()





-- Configuration
local TELEPORT_DELAY = 0.15 -- Time in seconds to wait at each physical target (reduced for speed)
local SEARCH_WAIT_TIME = 2.0 -- Time in seconds to wait between search attempts
local TIMER_STOP_VALUES = {"00:10", "00:20"} -- Values that trigger a sequence stop
local TIMER_START_THRESHOLD = "00:30" -- If the timer is <= this value when starting, abort the sequence
local MANNEQUIN_TEST_TIME = 5.0 -- Time in seconds to wait at each mannequin for testing (Reduced for speed)

-- The status message configuration
local VERSION_TEXT = "V3.4 Active - Event Cycle Endurance Mode" -- Updated version text for event duration
local STATUS_DURATION = 5.0
local STATUS_COLOR = Color3.fromRGB(255, 0, 0) -- Bright Red for high visibility
local RESTORE_COLOR = Color3.fromRGB(255, 255, 255) -- White (Used if original color can't be stored)

-- Services and Player Setup
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Wait for the character and HumanoidRootPart to be ready
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

-- Global Control Flags
local IS_SCRIPT_ACTIVE = true        -- Is the entire script running (controlled by main UI toggle)
local IS_AUTO_PET_CLICK_ACTIVE = true -- NEW: Controls pet clicking within the sequence
local IsSequenceActive = false       -- Is the teleport/click sequence currently running? (internal game state)
local ShouldStop = false             -- Has the timer triggered a stop signal? (internal game state)

-- State for prioritization across game rounds
local cycleCount = 0

-- Define the path components up to the MINIGAME container
local MINIGAME_CONTAINER_COMPONENTS = {
    "Interiors",
    "FashionFrenzy", -- The script handles the UID suffix when searching for this object.
    "Customize",
    "Minigame" -- This is the common parent container
}

-- UI Element Holders (Added for the control panel)
local statusLabel = nil
local toggleButton = nil
local petClickToggleButton = nil -- NEW: Handle for the new button
local screenGui = nil -- Store the main ScreenGui

--------------------------------------------------------------------------------
-- ðŸŽ® UI Control Functions
--------------------------------------------------------------------------------

-- Function to update the control panel status text
local function updateControlStatus(text)
    if statusLabel then
        statusLabel.Text = "[FF Mode] " .. text
    end
end

-- Function to update the main toggle button's appearance
local function updateToggleButton()
    if toggleButton then
        if IS_SCRIPT_ACTIVE then
            toggleButton.Text = "FF SCRIPT: ON"
            toggleButton.BackgroundColor3 = Color3.new(0, 1, 0) -- Green
            updateControlStatus("Active. Searching for new round...")
        else
            toggleButton.Text = "FF SCRIPT: OFF"
            toggleButton.BackgroundColor3 = Color3.new(1, 0, 0) -- Red
            updateControlStatus("OFF. Click ON to resume search.")
        end
    end
end

-- NEW Function to update the Pet Click button's appearance
local function updatePetClickToggleButton()
    if petClickToggleButton then
        if IS_AUTO_PET_CLICK_ACTIVE then
            petClickToggleButton.Text = "Auto Pet Click: ON"
            petClickToggleButton.BackgroundColor3 = Color3.fromRGB(0, 128, 255) -- Blue
            petClickToggleButton.TextColor3 = Color3.new(1, 1, 1)
        else
            petClickToggleButton.Text = "Auto Pet Click: OFF"
            petClickToggleButton.BackgroundColor3 = Color3.new(0.5, 0.5, 0.5) -- Gray
            petClickToggleButton.TextColor3 = Color3.new(1, 1, 1)
        end
    end
end

-- Function to handle the ON/OFF toggle
local function onToggleClicked()
    IS_SCRIPT_ACTIVE = not IS_SCRIPT_ACTIVE
    updateToggleButton()
end

-- NEW Function to handle the Auto Pet Click toggle
local function onPetClickToggleClicked()
    IS_AUTO_PET_CLICK_ACTIVE = not IS_AUTO_PET_CLICK_ACTIVE
    updatePetClickToggleButton()
    print(string.format("Auto Pet Click mode set to: %s", IS_AUTO_PET_CLICK_ACTIVE and "ACTIVE" or "INACTIVE"))
    updateControlStatus(string.format("Pet Click Toggled: %s", IS_AUTO_PET_CLICK_ACTIVE and "ON" or "OFF"))
end


-- Function to handle the Close Button click
local function onCloseClicked()
    if screenGui then
        IS_SCRIPT_ACTIVE = false -- Stop the loop
        screenGui:Destroy()
        warn("Fashion Frenzy Script UI destroyed.")
    end
end

-- Function to create the full UI (Status, Toggle, Close, Pet Click)
local function createFullUI()
    local playerGui = LocalPlayer:WaitForChild("PlayerGui")

    -- Main ScreenGui
    screenGui = Instance.new("ScreenGui")
    screenGui.Name = "FashionFrenzyControlUI"
    screenGui.Parent = playerGui

    -- UI Container Frame (Holds all controls, now taller)
    local controlFrame = Instance.new("Frame")
    controlFrame.Name = "ControlPanel"
    -- INCREASED HEIGHT: 80 (Status + Main Buttons) + 45 (Pet Click Button + Padding) = 125
    controlFrame.Size = UDim2.new(0, 600, 0, 125)
    controlFrame.Position = UDim2.new(0.5, -300, 0, 200) -- Centered, moved down to 200 pixels
    controlFrame.BackgroundColor3 = Color3.new(0.1, 0.1, 0.1)
    controlFrame.BackgroundTransparency = 0.1
    controlFrame.BorderSizePixel = 0
    controlFrame.Parent = screenGui

    -- Status Text Label (Top part of the frame)
    statusLabel = Instance.new("TextLabel")
    statusLabel.Name = "ScriptStatus"
    statusLabel.Size = UDim2.new(1, 0, 0, 30) -- Full width, 30 height
    statusLabel.Position = UDim2.new(0, 0, 0, 0)
    statusLabel.BackgroundColor3 = Color3.new(0, 0, 0)
    statusLabel.BackgroundTransparency = 0.3
    statusLabel.BorderSizePixel = 0
    statusLabel.Text = "Initializing Fashion Frenzy System..."
    statusLabel.TextColor3 = Color3.new(1, 1, 1)
    statusLabel.Font = Enum.Font.SourceSans
    statusLabel.TextSize = 18
    statusLabel.TextXAlignment = Enum.TextXAlignment.Center
    statusLabel.TextYAlignment = Enum.TextYAlignment.Center
    statusLabel.Parent = controlFrame

    -- Main Toggle Button (Left side, position Y: 35)
    toggleButton = Instance.new("TextButton")
    toggleButton.Name = "ToggleButton"
    toggleButton.Size = UDim2.new(0.7, -10, 0, 40)
    toggleButton.Position = UDim2.new(0, 5, 0, 35)
    toggleButton.BackgroundColor3 = Color3.new(1, 1, 1)
    toggleButton.Text = "FF SCRIPT: OFF/ON"
    toggleButton.TextColor3 = Color3.new(0, 0, 0)
    toggleButton.Font = Enum.Font.SourceSansBold
    toggleButton.TextSize = 20
    toggleButton.Parent = controlFrame
    toggleButton.MouseButton1Click:Connect(onToggleClicked)

    -- Close Button (Right side, position Y: 35)
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0.3, -5, 0, 40)
    closeButton.Position = UDim2.new(0.7, 5, 0, 35)
    closeButton.BackgroundColor3 = Color3.new(1, 0, 0) -- BRIGHT RED
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.new(1, 1, 1)
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.TextSize = 24
    closeButton.Parent = controlFrame
    closeButton.MouseButton1Click:Connect(onCloseClicked)

    -- NEW: Auto Pet Click Toggle Button (Position Y: 80 - below main buttons)
    petClickToggleButton = Instance.new("TextButton")
    petClickToggleButton.Name = "AutoPetClickToggle"
    petClickToggleButton.Size = UDim2.new(1, -10, 0, 40) -- Full width minus padding
    petClickToggleButton.Position = UDim2.new(0, 5, 0, 80) -- 30 (Status) + 40 (Toggle) + 10 (Padding) = 80
    petClickToggleButton.BackgroundColor3 = Color3.new(1, 1, 1)
    petClickToggleButton.Text = "Auto Pet Click: OFF/ON"
    petClickToggleButton.TextColor3 = Color3.new(0, 0, 0)
    petClickToggleButton.Font = Enum.Font.SourceSansBold
    petClickToggleButton.TextSize = 18
    petClickToggleButton.Parent = controlFrame
    petClickToggleButton.MouseButton1Click:Connect(onPetClickToggleClicked)

    -- Initial state update
    updateToggleButton()
    updatePetClickToggleButton() -- NEW: Initialize the pet button
end

--------------------------------------------------------------------------------
-- STATUS UI HANDLER
--------------------------------------------------------------------------------

-- Displays the version status message in red for 3 seconds.
local function displayVersionStatus()
    -- Use robust WaitForChild to ensure the container exists
    local HintAppContainer = LocalPlayer.PlayerGui:WaitForChild("HintApp", 2)
    local uiElement = HintAppContainer and HintAppContainer:FindFirstChild("LargeTextLabel")

    if uiElement and uiElement:IsA("TextLabel") then
        print(string.format("Displaying version status: '%s' in red for %d seconds.", VERSION_TEXT, STATUS_DURATION))
        updateControlStatus(VERSION_TEXT) -- Also update the control panel status

        -- Store original properties to restore them later
        local originalTextTransparency = uiElement.TextTransparency
        local originalTextColor = uiElement.TextColor3 -- Store the original color of the label

        uiElement.Text = VERSION_TEXT
        uiElement.TextTransparency = 0
        uiElement.TextColor3 = STATUS_COLOR

        task.wait(STATUS_DURATION)

        -- Restore state: clear text and restore color and transparency
        uiElement.Text = ""
        uiElement.TextColor3 = originalTextColor -- Restore the original color
        uiElement.TextTransparency = originalTextTransparency
    else
        warn("Could not find PlayerGui.HintApp.LargeTextLabel. Skipping status display.")
    end
end

--------------------------------------------------------------------------------
-- TIMER MONITOR THREAD
--------------------------------------------------------------------------------

-- Utility function to read the current timer text from the GUI
local function getCurrentTimerText()
    -- Find the timer label relative to the PlayerGui
    local valueLabel = LocalPlayer.PlayerGui:FindFirstChild("FashionFrenzyInGameApp", true)

    if valueLabel and valueLabel:IsA("ScreenGui") then
        -- Traverse the remaining path
        valueLabel = valueLabel:FindFirstChild("Body")
            and valueLabel.Body:FindFirstChild("Left")
            and valueLabel.Body.Left:FindFirstChild("Container")
            and valueLabel.Body.Left.Container:FindFirstChild("ValueLabel")
    end

    if valueLabel and valueLabel:IsA("TextLabel") then
        return valueLabel.Text
    end
    return nil
end

-- Function to safely wait for a duration while checking the global stop flag
local function waitWithStopCheck(duration)
    local checkInterval = 1 -- Check every 1 second
    local remaining = duration

    while remaining > 0 and not ShouldStop do
        local waitTime = math.min(checkInterval, remaining)
        task.wait(waitTime)
        remaining = remaining - checkInterval
    end
end

local function timerMonitor()
    while true do
        if IsSequenceActive then
            local text = getCurrentTimerText()

            if text then
                -- Check if the current time matches any of the stop values
                for _, stopValue in ipairs(TIMER_STOP_VALUES) do
                    if text == stopValue then
                        if not ShouldStop then
                            print(string.format("!! TIMER HIT STOP VALUE (%s). Stopping sequence and preparing to restart search.", stopValue))
                            updateControlStatus(string.format("Timer hit %s! Cycle ended.", stopValue))
                            ShouldStop = true
                            break
                        end
                    end
                end
            end
        end
        task.wait(0.1) -- Check the timer frequently
    end
end

task.spawn(timerMonitor)

-- Create the UI and display initial version status
createFullUI()
displayVersionStatus()

--------------------------------------------------------------------------------
-- GUI INTERACTION FUNCTIONS (Integrated Click Logic)
--------------------------------------------------------------------------------

-- Function to simulate click events using the most reliable getconnections method.
-- This follows the specific time sequence requested (wait(0.1) between fires).
local function clickButton(button)
    if ShouldStop or not IS_SCRIPT_ACTIVE then return end -- Check before clicking

    if not button or not getconnections then
        return
    end

    print("Attempting to click:", button.Name, "(Type:", button.ClassName, ")")

    -- 1. Attempt to simulate MouseButton1Down
    for _, connection in pairs(getconnections(button.MouseButton1Down)) do
        connection:Fire()
    end
    task.wait(0.1) -- Time sequence delay

    -- 2. Attempt to simulate MouseButton1Click
    for _, connection in pairs(getconnections(button.MouseButton1Click)) do
        connection:Fire()
    end
    task.wait(0.1) -- Time sequence delay

    -- 3. Attempt to simulate MouseButton1Up
    for _, connection in pairs(getconnections(button.MouseButton1Up)) do
        connection:Fire()
    end

    -- EXPLICIT CLICK CONFIRMATION
    print("Successfully fired events for:", button.Name)
end

-- Helper function to open the main Inventory/Backpack UI before finding the pet
local function openMainInventory()
    if ShouldStop or not IS_SCRIPT_ACTIVE then return end
    -- Common names for the main backpack button in the PlayerGui
    local button = LocalPlayer.PlayerGui:FindFirstChild("InventoryButton", true)
    if not button then
        button = LocalPlayer.PlayerGui:FindFirstChild("BackpackButton", true)
    end

    if button and button:IsA("GuiObject") then
        print("Explicitly clicking the main Inventory/Backpack UI button.")
        clickButton(button)
        -- Give UI a moment to start loading the BackpackApp
        task.wait(0.2)
    else
        warn("Could not find the main Backpack/Inventory UI button. Skipping explicit open.")
    end
end

-- Clicks all available pet buttons in BackpackApp by performing a targeted search.
local function findAndClickPetButton()
    if ShouldStop or not IS_SCRIPT_ACTIVE then return end
    
    -- NEW: Check the pet click toggle flag
    if not IS_AUTO_PET_CLICK_ACTIVE then
        print("Auto Pet Click is OFF. Skipping pet selection this cycle.")
        return
    end

    local gui = LocalPlayer.PlayerGui
    local BackpackApp = nil
    local waitTimeout = 5 -- Wait up to 5 seconds for the UI to appear
    local startTime = tick()

    -- 1. WAIT for the main BackpackApp GUI to appear after clicking the inventory button
    repeat
        BackpackApp = gui:FindFirstChild("BackpackApp")
        if not BackpackApp then
            task.wait(0.1)
        end
    until BackpackApp or ShouldStop or (tick() - startTime > waitTimeout)

    if not BackpackApp then
        warn(string.format("BackpackApp GUI failed to open or load within %d seconds. Skipping pet selection this cycle.", waitTimeout))
        return
    end

    -- 2. Traverse the path to the 'pets' container
    local scrollingFrame = BackpackApp:FindFirstChild("Frame")
        and BackpackApp.Frame:FindFirstChild("Body")
        and BackpackApp.Frame.Body:FindFirstChild("ScrollComplex")
        and BackpackApp.Frame.Body.ScrollComplex:FindFirstChild("ScrollingFrame")

    if not scrollingFrame then
        warn("BackpackApp ScrollingFrame not found. Skipping pet selection this cycle.")
        return
    end

    -- We check both 'Content/pets' (common structure) and directly for 'Row0' (user path)
    local petsContainer = scrollingFrame:FindFirstChild("Content") and scrollingFrame.Content:FindFirstChild("pets")

    -- Fallback to searching the ScrollingFrame itself if the Content/pets path is missing,
    -- or if the items are directly placed (e.g., Row0).
    local containerToSearch = petsContainer or scrollingFrame

    if not containerToSearch then
        warn("Could not find a valid pet container (pets or ScrollingFrame). Skipping pet selection.")
        return
    end

    print("Searching for ALL usable pet buttons within the item containers...")

    local foundPetButton = false

    -- Iterate through all children (which should be the rows or item frames, e.g., 'Row0', 'Row1', or dynamic item names)
    for _, petContainer in ipairs(containerToSearch:GetChildren()) do
        if ShouldStop or not IS_SCRIPT_ACTIVE then return end

        -- Explicitly check and skip any container related to "add_more_pets"
        if petContainer.Name:lower():match("add_more_pets") then
            print(string.format("Skipping excluded container: %s", petContainer.Name))
            continue
        end

        local targetElement = nil

        -- 3. Targeted Fix: Find the nested Frame *inside* the pet container
        local nestedFrame = petContainer:FindFirstChild("Frame", false)

        if nestedFrame and nestedFrame:IsA("GuiObject") then
            -- 4. Look for the button inside that nested Frame (using recursive search just in case)
            targetElement = nestedFrame:FindFirstChild("Button", true)
            if not targetElement then
                targetElement = nestedFrame:FindFirstChild("TapButton", true)
            end
        end

        -- Fallback: If the button wasn't in a nested Frame, check if it's directly inside the pet container
        if not targetElement then
            targetElement = petContainer:FindFirstChild("Button", true) or petContainer:FindFirstChild("TapButton", true)
            if not targetElement and (petContainer:IsA("TextButton") or petContainer:IsA("ImageButton")) then
                   -- Final fallback: Check if the container itself is the clickable button
                targetElement = petContainer
            end
        end


        -- Execute the click
        if targetElement and (targetElement:IsA("TextButton") or targetElement:IsA("ImageButton")) then
            print(string.format("Clicking Pet Button: %s (Parent: %s)", targetElement.Name, targetElement.Parent.Name))
            clickButton(targetElement)
            foundPetButton = true
            task.wait(0.05) -- Small delay between clicks
        end
    end

    if not foundPetButton then
        warn("No usable pet buttons found inside the item containers after deep search.")
    else
        print("Finished clicking all available pet buttons in the BackpackApp.")
    end
end


-- Clicks the Backpack Exit button
local function closeBackpack()
    if ShouldStop or not IS_SCRIPT_ACTIVE then return end

    local exitButton = LocalPlayer.PlayerGui:FindFirstChild("BackpackApp")
        and LocalPlayer.PlayerGui.BackpackApp:FindFirstChild("Frame")
        and LocalPlayer.PlayerGui.BackpackApp.Frame:FindFirstChild("Header")
        and LocalPlayer.PlayerGui.BackpackApp.Frame.Header:FindFirstChild("ExitButton")

    if exitButton then
        print("Closing Backpack App.")
        clickButton(exitButton)
    else
        warn("Backpack ExitButton not found.")
    end
end

-- Clicks all buttons in the BasicSelects container
local function clickAllBasicSelects()
    if ShouldStop or not IS_SCRIPT_ACTIVE then return end

    local basicSelectsContainer = LocalPlayer.PlayerGui:FindFirstChild("InteractionsApp")
        and LocalPlayer.PlayerGui.InteractionsApp:FindFirstChild("BasicSelects")

    if not basicSelectsContainer then
        warn("InteractionsApp.BasicSelects container not found. Skipping clicks.")
        return
    end

    local clickCount = 0
    -- Clicks the nested TapButton inside each Template frame
    for _, templateFrame in ipairs(basicSelectsContainer:GetChildren()) do
        if ShouldStop or not IS_SCRIPT_ACTIVE then return end -- Check inside the loop

        if templateFrame:IsA("GuiObject") then
            -- Use the recursive FindFirstChild(name, true) to search deeply
            -- inside the templateFrame for the TapButton, handling nested frames.
            local buttonToClick = templateFrame:FindFirstChild("TapButton", true)

            if buttonToClick and (buttonToClick:IsA("TextButton") or buttonToClick:IsA("ImageButton")) then
                clickButton(buttonToClick)
                clickCount = clickCount + 1
                -- Clicks are instantaneous for max aggressiveness
            end
        end
    end
    print(string.format("Clicked %d BasicSelect buttons.", clickCount))
end

--------------------------------------------------------------------------------
-- UTILITY & TELEPORT FUNCTIONS
--------------------------------------------------------------------------------

-- Helper function to find a child whose name starts with a specific prefix.
local function findChildByPrefix(parent, prefix)
    for _, child in ipairs(parent:GetChildren()) do
        if child.Name:sub(1, #prefix) == prefix then
            return child
        end
    end
    return nil
end

-- Function to find the best physical part to teleport to within a model.
-- This prioritizes a specific part name (like HRP, Paw, or Head) but falls back to any BasePart.
local function findBestPartToTeleportTo(model, primaryName)
    -- 1. Check for the primary part (e.g., Head, Paw) recursively
    local primaryPart = model:FindFirstChild(primaryName, true)
    if primaryPart and primaryPart:IsA("BasePart") then
        return primaryPart
    end

    -- 2. Check if the model itself is a part
    if model:IsA("BasePart") then
        return model
    end

    -- 3. Fallback: Find the first BasePart (or MeshPart, Part, etc.) recursively
    for _, descendant in ipairs(model:GetDescendants()) do
        if descendant:IsA("BasePart") then
            -- Ensure we don't accidentally fall back to HumanoidRootPart if it exists and wasn't the primary search
            if primaryName ~= "HumanoidRootPart" and descendant.Name == "HumanoidRootPart" then
                continue
            end
            return descendant
        end
    end

    return nil
end

-- Function to handle the marker creation and teleportation
local function TeleportTo(position)
    if ShouldStop or not IS_SCRIPT_ACTIVE then return end -- Check before teleporting

    -- Create the small target cube (Teleport Marker)
    local marker = Instance.new("Part")
    marker.Name = "TeleportMarker"
    marker.Size = Vector3.new(1.5, 1.5, 1.5)
    marker.Position = position + Vector3.new(0, 3, 0)
    marker.Transparency = 0.2
    marker.Anchored = true
    marker.CanCollide = false
    marker.BrickColor = BrickColor.new("Really red")
    marker.Material = Enum.Material.Neon
    marker.Parent = Workspace

    -- Teleport the character's HumanoidRootPart to the marker's location
    HumanoidRootPart.CFrame = CFrame.new(position + Vector3.new(0, 5, 0))

    -- Wait at the location
    task.wait(TELEPORT_DELAY)

    -- Clean up the marker
    marker:Destroy()
end

-- Function to find the position of the first available Paw part (now uses robust finding)
local function findFirstPawPosition(minigameContainer)
    local petPodiumsContainer = minigameContainer:FindFirstChild("PetPodiums")
    if not petPodiumsContainer then return nil end

    for _, podiumModel in ipairs(petPodiumsContainer:GetChildren()) do
        -- Use the robust search on the podium model, prioritizing "Paw"
        local targetPart = findBestPartToTeleportTo(podiumModel, "Paw")

        if targetPart then
            return targetPart.Position
        end
    end
    return nil
end

-- Function to find the position of the first Mannequin (used for fallback teleport)
local function findFirstMannequinPosition(minigameContainer)
    local mannequinsContainer = minigameContainer:FindFirstChild("AccessoryMannequins")
    if not mannequinsContainer then return nil end

    for _, mannequinModel in ipairs(mannequinsContainer:GetChildren()) do
        -- Prioritize "Head" as the teleport target
        local targetPart = findBestPartToTeleportTo(mannequinModel, "Head")

        if targetPart then
            return targetPart.Position
        end
    end
    return nil
end


--------------------------------------------------------------------------------
-- TELEPORT SEQUENCE FUNCTIONS
--------------------------------------------------------------------------------

-- Function to handle Mannequin teleportation and accessory equip cycle (The "others" step)
local function teleportToMannequins(minigameContainer, returnPosition)
    print("--- STARTING MANNEQUIN TELEPORT & ACCESSORY CYCLE ---")
    local mannequinsContainer = minigameContainer:FindFirstChild("AccessoryMannequins")

    if not mannequinsContainer or ShouldStop or not IS_SCRIPT_ACTIVE then warn("Mannequin container not found or sequence stopped."); return end
    updateControlStatus("Running Mannequin cycle...")

    local targetsFound = 0
    for _, mannequinModel in ipairs(mannequinsContainer:GetChildren()) do
        if ShouldStop or not IS_SCRIPT_ACTIVE then return end -- Stop check

        targetsFound = targetsFound + 1
        -- Prioritize "Head" as the teleport target
        local targetPart = findBestPartToTeleportTo(mannequinModel, "Head")

        if targetPart then
            print(string.format("[MANNEQUIN %d] Teleporting to Mannequin: %s (Target: %s)", targetsFound, mannequinModel.Name, targetPart.Name))
            updateControlStatus(string.format("Mannequin: %d - Testing accessories", targetsFound))

            -- 1. Teleport to Mannequin HRP/Part
            TeleportTo(targetPart.Position)

            -- 2. Click all buttons in BasicSelects (Accessory Selection)
            clickAllBasicSelects()
            if ShouldStop or not IS_SCRIPT_ACTIVE then return end

            -- 3. Wait 5 seconds (safe wait with timer check)
            print(string.format("[MANNEQUIN %d] Waiting %d seconds for accessory testing...", targetsFound, MANNEQUIN_TEST_TIME))
            waitWithStopCheck(MANNEQUIN_TEST_TIME)
            if ShouldStop or not IS_SCRIPT_ACTIVE then return end

            -- 4. Teleport back to Paw position to finalize accessory selection
            if returnPosition then
                print(string.format("[MANNEQUIN %d] Confirmation Step: Teleporting back to return position for finalize click.", targetsFound))
                updateControlStatus(string.format("Mannequin: %d - Finalizing choice", targetsFound))

                TeleportTo(returnPosition)
                if ShouldStop or not IS_SCRIPT_ACTIVE then return end

                -- ADDED STABILIZATION DELAY to allow the UI to refresh/re-activate
                task.wait(0.2)

                -- 5. Click all buttons in BasicSelects again (Confirmation/Put On) with RETRY
                print(string.format("[MANNEQUIN %d] Confirmation Step: Clicking BasicSelects again (3 attempts) to confirm accessory.", targetsFound))

                -- *** ADDED RETRY LOOP HERE ***
                for attempt = 1, 3 do
                    clickAllBasicSelects()
                    task.wait(0.1) -- Short wait between retries
                end

                if ShouldStop or not IS_SCRIPT_ACTIVE then return end
            else
                -- Log a specific warning about the skipped steps
                warn(string.format("[MANNEQUIN %d] Return position (Paw/Fallback) was nil. Skipping accessory confirmation clicks (Steps 4 & 5).", targetsFound))
                updateControlStatus(string.format("Mannequin: %d - Skipped confirmation", targetsFound))
            end

        else
            warn(string.format("Mannequin %s does not have a suitable part (Head or BasePart) for teleporting. Skipping.", mannequinModel.Name))
        end
    end

    if not ShouldStop and IS_SCRIPT_ACTIVE then
        print(string.format("--- Mannequin Cycle Finished. Visited %d locations. ---", targetsFound))
        updateControlStatus("Mannequin Cycle Finished.")
    end
end

-- Function containing the main execution logic
local function runFullSequence(minigameContainer)
    local initialTime = getCurrentTimerText()

    -- PRE-SEQUENCE TIMER CHECK: If the time is too low (e.g., 00:30 or lower), abort the start.
    if initialTime and (initialTime <= TIMER_START_THRESHOLD) then
        print(string.format("!! Initial timer check failed: %s is <= %s. Round is too late. Resetting search.", initialTime, TIMER_START_THRESHOLD))
        updateControlStatus(string.format("Round too late (%s). Awaiting new game.", initialTime))
        return
    end

    -- Increment the cycle count for this attempt
    cycleCount = cycleCount + 1

    print(string.format("--- Starting Full Sequence (Cycle #%d). ---", cycleCount))
    updateControlStatus(string.format("Starting Cycle #%d: Initial Setup", cycleCount))

    IsSequenceActive = true

    -- 1. Determine the Paw position (This is the critical return point for accessory confirmation).
    local pawPosition = findFirstPawPosition(minigameContainer)
    local returnPositionForMannequins = pawPosition -- Use pawPosition as the primary return point

    -- FALLBACK check: If Paw is missing, find a Mannequin to use for the initial setup teleport.
    if not pawPosition then
        -- If Paw is missing, we use the first Mannequin as the initial equip point.
        local firstMannequinPosition = findFirstMannequinPosition(minigameContainer)

        if firstMannequinPosition then
            print("!! WARNING: Paw position not found. Initial setup will be performed at the first Mannequin.")
            -- Temporarily set pawPosition to the mannequin for the initial setup block to run.
            pawPosition = firstMannequinPosition
        else
            warn("!! CRITICAL: Neither Paw nor Mannequin found. Skipping initial setup.")
            updateControlStatus("CRITICAL: Paw/Mannequin not found. Skipping cycle.")
        end
    end

    -- ----------------------------------------------------
    -- INITIAL SETUP SEQUENCE (PAW -> ACCESSORIES -> PETS)
    -- ----------------------------------------------------
    if pawPosition and not ShouldStop and IS_SCRIPT_ACTIVE then
        print("--- START OF ROUND SETUP: Executing strict start sequence (Paw -> Accessories -> Pets). ---")

        -- 1. Teleport to Paw (or Mannequin fallback)
        TeleportTo(pawPosition)
        if ShouldStop or not IS_SCRIPT_ACTIVE then return end

        -- 2. Click all BasicSelects buttons (initial accessory equip)
        print("--- SETUP: Clicking all BasicSelects buttons (Accessories). ---")
        updateControlStatus("Setup: Clicking BasicSelects...")
        clickAllBasicSelects()
        if ShouldStop or not IS_SCRIPT_ACTIVE then return end

        -- 3. Open the Backpack and then select all pets (ONLY IF TOGGLED ON)
        if IS_AUTO_PET_CLICK_ACTIVE then
            print("--- SETUP: Opening backpack, selecting ALL pets, and closing (Auto Pet Click ON). ---")
            updateControlStatus("Setup: Selecting all Pets...")
            openMainInventory()
            if ShouldStop or not IS_SCRIPT_ACTIVE then return end
            findAndClickPetButton() -- This is the key fix area
            if ShouldStop or not IS_SCRIPT_ACTIVE then return end
            closeBackpack()
            if ShouldStop or not IS_SCRIPT_ACTIVE then return end
        else
            print("--- SETUP: Skipping pet selection (Auto Pet Click OFF). ---")
            updateControlStatus("Setup: Pet selection skipped.")
        end

        print("--- SETUP COMPLETE. Proceeding to Mannequin cycles (The 'others'). ---")
        updateControlStatus("Setup Complete. Starting Mannequin Cycle.")
    else
        warn("!! CRITICAL: Paw position not found, and initial setup was skipped.")
    end

    -- Delay before starting the timed cycles
    if not ShouldStop and IS_SCRIPT_ACTIVE then
        task.wait(TELEPORT_DELAY) -- Shortened wait time for speed
    end
    -- ----------------------------------------------------
    -- END INITIAL SETUP SEQUENCE
    -- ----------------------------------------------------

    -- 4. Execute Mannequin sequence (The "others")
    if not ShouldStop and IS_SCRIPT_ACTIVE then
        -- This variable holds the position for the return teleport
        teleportToMannequins(minigameContainer, returnPositionForMannequins)
    end

    -- Final status update
    if not ShouldStop and IS_SCRIPT_ACTIVE then
        print("--- FULL SEQUENCE COMPLETE. Waiting for timer reset to continue loop. ---")
        updateControlStatus("Cycle Finished. Awaiting new game...")
    else
        print("--- Sequence was interrupted by timer or shut off. Resetting to search state. ---")
        updateControlStatus("Cycle Interrupted. Awaiting search reset.")
    end

    IsSequenceActive = false
    ShouldStop = false -- Reset stop flag for the next cycle
end


--------------------------------------------------------------------------------
-- MAIN SCRIPT LOOP (CONTINUOUS SEARCH & RESTART)
--------------------------------------------------------------------------------

while true do
    -- Check if the script is active based on the UI toggle
    while not IS_SCRIPT_ACTIVE do
        task.wait(1)
    end

    -- Continuous Search Output
    print(string.format("Searching For %s Interior...", MINIGAME_CONTAINER_COMPONENTS[2]))
    updateControlStatus(string.format("Searching For %s Interior...", MINIGAME_CONTAINER_COMPONENTS[2]))

    local minigameContainer = Workspace
    local foundAll = true

    -- Traverse the path to find the common MINIGAME container
    for i, name in ipairs(MINIGAME_CONTAINER_COMPONENTS) do
        if not minigameContainer then break end

        if name == "FashionFrenzy" then
            minigameContainer = findChildByPrefix(minigameContainer, name)
        elseif i == 1 then
            -- Using WaitForChild for the top-level folder
            minigameContainer = minigameContainer:WaitForChild(name, SEARCH_WAIT_TIME)
        else
            minigameContainer = minigameContainer:FindFirstChild(name)
        end

        if not minigameContainer then
            -- Only warn if it's the target component that couldn't be found
            if i > 1 then warn("Could not find container at path component: " .. name) end
            foundAll = false
            break
        end
    end

    -- If the container is found (implying the game round has started), run the sequence
    if foundAll and minigameContainer then
        print("Minigame container found. Starting full teleport sequence.")
        runFullSequence(minigameContainer)
    end

    -- Wait before attempting to search/restart the cycle again
    task.wait(SEARCH_WAIT_TIME)
end





