--[[
    Roblox Minigame Teleporter (LocalScript)

    This script continuously monitors two specific TimerLabel Gui objects in the Workspace.
    When the text of either timer changes to contain the specific target times ("00:30" or "00:20"), 
    it teleports the LocalPlayer's character to the associated destination Part ("Ring").
    
    NEW FEATURE: 
    - It displays the full timer text on screen, cleaned of newlines.
    - It turns the display text RED when a teleport is about to occur (at 00:30 or 00:20).
    - It includes a **Close button** to destroy the UI and stop all monitoring logic.
    - **REVERTED:** UI is now two separate TextLabels and a Close button, not a single Frame.
    - **UPDATED:** The Close button's vertical position has been adjusted down.

    ***IMPORTANT: MUST BE A LOCAL SCRIPT IN StarterPlayerScripts***

    ***DEBUGGING ENABLED: If the script stops, the last message indicates the object it failed to find.***
--]]

print("--------------------------------------------------")
print("[SCRIPT START] Minigame Teleporter script is now running.")

-- Services and Global Variables
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- Configuration: Define the timers and their respective destinations using an array of object names.
local CONFIG = {
    FashionFrenzy = {
        -- Path: Workspace.Interiors["MainMap!Fall"].FashionFrenzyJoinZone.Billboard.BillboardGui.TimerLabel
        TimerPathParts = {'Interiors', 'MainMap!Fall', 'FashionFrenzyJoinZone', 'Billboard', 'BillboardGui', 'TimerLabel'},
        -- Path: Workspace.Interiors["MainMap!Fall"].FashionFrenzyJoinZone.Ring
        DestPathParts = {'Interiors', 'MainMap!Fall', 'FashionFrenzyJoinZone', 'Ring'},
        -- UI configuration
        UIName = "FashionFrenzyTimerDisplay",
        Position = UDim2.new(0.5, 0, 0.35, 0), -- Position of the first timer (35% down)
        Connection = nil -- Stores the connection object for cleanup
    },
    Hauntlet = {
        -- Path: Workspace.Interiors["MainMap!Fall"].HauntletMinigameJoinZone.Billboard.BillboardGui.TimerLabel
        TimerPathParts = {'Interiors', 'MainMap!Fall', 'HauntletMinigameJoinZone', 'Billboard', 'BillboardGui', 'TimerLabel'},
        -- Path: Workspace.Interiors["MainMap!Fall"].HauntletMinigameJoinZone.Ring
        DestPathParts = {'Interiors', 'MainMap!Fall', 'HauntletMinigameJoinZone', 'Ring'},
        -- UI configuration
        UIName = "HauntletTimerDisplay",
        Position = UDim2.new(0.5, 0, 0.40, 0), -- Position of the second timer (40% down)
        Connection = nil -- Stores the connection object for cleanup
    }
}

-- Position for the Close Button (placed near the top timer)
-- Changed the Y offset from -20 to +5 to move the button down slightly.
local CLOSE_BUTTON_POSITION = UDim2.new(0.5, 100, 0.35, 5) 

-- Default and Warning colors
local DEFAULT_COLOR = Color3.new(1, 1, 1)    -- White
local ALERT_COLOR = Color3.new(1, 0, 0)      -- Red

-- Store the main ScreenGui reference globally for easy destruction
local ScreenGuiRef = nil 

-- Utility function to safely find deep nested objects, waiting up to 10 seconds for each part
local function safeFind(pathParts) -- Takes an array of strings (object names)
    local current = Workspace 
    local currentPath = "Workspace"

    for _, partName in ipairs(pathParts) do
        print("[Path Check] Currently looking for: '" .. partName .. "' inside of '" .. current.Name .. "'")
        
        -- Wait up to 10 seconds for the next part of the path to exist
        local foundPart = current:WaitForChild(partName, 10) 
        currentPath = currentPath .. "['" .. partName .. "']"
        
        if not foundPart then
            warn("[Path ERROR] Failed to find: '" .. partName .. "'. The map might not be loaded yet, or the path is incorrect. (Full attempted path so far: " .. currentPath .. ")")
            return nil
        end
        current = foundPart
    end
    print("[Path Success] Found object: " .. currentPath)
    return current
end

-- Teleport function 
local function teleportPlayer(destinationPart)
    local Character = LocalPlayer.Character
    if not Character then 
        warn("[Teleport Fail] Character not found. Waiting for character to load...")
        Character = LocalPlayer.CharacterAdded:Wait()
    end

    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then 
        warn("[Teleport Fail] HumanoidRootPart not found. Cannot teleport.")
        return 
    end

    -- Move the character slightly above the destination part to prevent clipping
    local destinationCFrame = destinationPart.CFrame * CFrame.new(0, 5, 0) 
    HumanoidRootPart.CFrame = destinationCFrame
    print("[Teleport Success] Teleported to " .. destinationPart.Name)
end

-- Function to handle cleanup and stopping the script
local function stopMonitor()
    print("[Stop Monitor] Disconnecting all timer events and cleaning up UI.")
    
    -- Disconnect all connections stored in CONFIG
    for name, paths in pairs(CONFIG) do
        if paths.Connection then
            paths.Connection:Disconnect()
            paths.Connection = nil
            print("  - Disconnected " .. name .. " monitor.")
        end
    end

    -- Destroy the UI (will destroy the ScreenGui and everything inside it)
    if ScreenGuiRef and ScreenGuiRef.Parent then
        ScreenGuiRef:Destroy()
        ScreenGuiRef = nil
        print("  - Destroyed MinigameTimerUI.")
    end
end

-- UI Setup Function (Creates the ScreenGui and the Close button ONCE)
local function ensureScreenGuiAndCloseButton()
    local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
    
    -- 1. Setup ScreenGui 
    local ScreenGui = PlayerGui:FindFirstChild("MinigameTimerUI")
    if not ScreenGui then
        ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "MinigameTimerUI"
        ScreenGui.Parent = PlayerGui
        ScreenGuiRef = ScreenGui -- Set the global reference
    end
    
    -- 2. Create the Close Button (if it doesn't exist)
    local CloseButton = ScreenGui:FindFirstChild("CloseMonitorButton")
    if not CloseButton then
        CloseButton = Instance.new("TextButton")
        CloseButton.Name = "CloseMonitorButton"
        CloseButton.Size = UDim2.new(0, 50, 0, 20)
        -- Positioned to the right of the first timer label
        CloseButton.Position = CLOSE_BUTTON_POSITION 
        CloseButton.AnchorPoint = Vector2.new(0.5, 0)
        CloseButton.Text = "X Close"
        CloseButton.Font = Enum.Font.SourceSansBold
        CloseButton.TextSize = 14
        CloseButton.TextColor3 = Color3.new(1, 1, 1)
        CloseButton.BackgroundColor3 = Color3.new(0.8, 0.1, 0.1) -- Red background
        CloseButton.BorderSizePixel = 0
        CloseButton.Parent = ScreenGui -- Parented directly to the ScreenGui
        CloseButton.ZIndex = 3
        
        -- Connect the button click to the stopMonitor function
        CloseButton.MouseButton1Click:Connect(stopMonitor)
    end

    return ScreenGui
end

-- Function to create the individual TextLabel for a timer
local function createTimerLabel(configName, position)
    local ScreenGui = ensureScreenGuiAndCloseButton()
    
    local TimerDisplay = Instance.new("TextLabel")
    TimerDisplay.Name = configName
    TimerDisplay.Size = UDim2.new(0, 300, 0, 20) -- Fixed size
    TimerDisplay.Position = position
    TimerDisplay.AnchorPoint = Vector2.new(0.5, 0) -- Center horizontally
    TimerDisplay.Text = configName .. " Timer: Waiting..."
    TimerDisplay.Font = Enum.Font.SourceSansBold
    TimerDisplay.TextSize = 16 
    TimerDisplay.TextColor3 = DEFAULT_COLOR
    TimerDisplay.TextScaled = false
    TimerDisplay.TextWrapped = true
    TimerDisplay.BackgroundColor3 = Color3.new(0.1, 0.1, 0.1)
    TimerDisplay.BackgroundTransparency = 0.8 -- Slightly transparent background
    TimerDisplay.BorderSizePixel = 0
    TimerDisplay.Parent = ScreenGui
    TimerDisplay.ZIndex = 2 
    TimerDisplay.TextXAlignment = Enum.TextXAlignment.Left 

    -- Add a small shadow
    TimerDisplay.TextStrokeTransparency = 0.8 
    
    return TimerDisplay
end

-- Function to set up monitoring for a single minigame
local function setupMinigameMonitor(configName, paths)
    -- 0. Create the UI element for display
    local uiDisplay = createTimerLabel(paths.UIName, paths.Position)
    
    -- 1. Safely find the TimerLabel (source)
    local timerLabel = safeFind(paths.TimerPathParts)
    if not timerLabel or not timerLabel:IsA("TextLabel") then
        warn("[Setup Fail] Failed to find valid TextLabel for " .. configName .. ". Aborting monitor setup.")
        uiDisplay.Text = configName .. " Timer: [ERROR - Path Failed]"
        return
    end

    -- 2. Safely find the Destination Part
    local destinationPart = safeFind(paths.DestPathParts)
    if not destinationPart or not destinationPart:IsA("BasePart") then
        warn("[Setup Fail] Failed to find valid Destination Part for " .. configName .. ". Aborting monitor setup.")
        return
    end

    print("[Monitor Active] Monitoring " .. configName .. " timer.")

    -- 3. Define the monitoring logic
    local function checkTimer(newText)
        local rawText = newText or timerLabel.Text
        
        -- CLEANUP: Remove newlines and carriage returns for clean display and reliable detection
        local text = rawText:gsub("[\r\n]", "")
        
        -- DEBUG: Print the exact text being detected every time it changes
        print("[Text Update] " .. configName .. " timer text changed to: '" .. text .. "'")

        -- Teleport Logic
        local target30 = "00:30"
        local target20 = "00:20"
        
        -- The string.find check uses the CLEANED text
        local isAlertTime = string.find(text, target30) or string.find(text, target20)

        -- UI Update: Update the on-screen display and color
        -- Revert text formatting for floating labels (less space)
        uiDisplay.Text = text 
        
        if isAlertTime then
            uiDisplay.TextColor3 = ALERT_COLOR -- Turn text RED for alert
            print("ALERT: " .. configName .. " is at target time.")
            
            -- Initiate teleport immediately after visual warning
            teleportPlayer(destinationPart)
        else
            uiDisplay.TextColor3 = DEFAULT_COLOR -- Keep text white otherwise
        end
    end

    -- 4. Connect the check to the Text property change event and store the connection
    local connection = timerLabel:GetPropertyChangedSignal("Text"):Connect(checkTimer)
    CONFIG[configName].Connection = connection

    -- Also run once on startup, just in case the timer is already at a target value
    checkTimer()
end

-- NEW STARTUP SEQUENCE: Start monitor tasks immediately. The 'safeFind' calls will handle the waiting.
print("[Setup] Starting monitor tasks now (will wait for map parts)...")

-- Run setup for all configured minigames
for name, paths in pairs(CONFIG) do
    -- task.spawn ensures monitors run concurrently without blocking the main script loop
    task.spawn(setupMinigameMonitor, name, paths) 
end
