--[[
    Roblox Minigame Teleporter (LocalScript)

    This script continuously monitors specific TextLabel Gui objects in the Workspace.
    When the text of the timer changes to contain the specific target times ("00:30" or "00:20"),
    it teleports the LocalPlayer's character to the associated destination Part ("Ring").

    ENHANCEMENT: Added 'SleepOrTreat' minigame to the monitoring configuration.

    CRITICAL FIX FOR MONITORING STOPPAGE:
    - The monitoring logic is now contained within a **persistent while true do loop**.
    - If the target Timer object is destroyed (due to game streaming/map cycle), the loop will
      automatically search for the object again and **re-establish the connection**.
    
    FIX/ENHANCEMENTS:
    - Removed 'goto' statements for improved compatibility.
    - Added an internal **hasTeleported** flag (debounce) to prevent duplicate teleports.
    - Teleport function includes a retry loop for character availability (resilience against respawns).
    
    ***IMPORTANT: MUST BE A LOCAL SCRIPT IN StarterPlayerScripts***
--]]

print("--------------------------------------------------")
print("[SCRIPT START] Minigame Teleporter script is now running.")

-- Services and Global Variables
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- Configuration: Define the timers and their respective destinations.
local CONFIG = {
    FashionFrenzy = {
        -- Path: Workspace.Interiors["MainMap!Fall"].FashionFrenzyJoinZone.Billboard.BillboardGui.TimerLabel
        TimerPathParts = {'Interiors', 'MainMap!Fall', 'FashionFrenzyJoinZone', 'Billboard', 'BillboardGui', 'TimerLabel'},
        -- Path: Workspace.Interiors["MainMap!Fall"].FashionFrenzyJoinZone.Ring
        DestPathParts = {'Interiors', 'MainMap!Fall', 'FashionFrenzyJoinZone', 'Ring'},
        -- Runtime References
        TimerObject = nil, -- **NEW: Stores the current TextLabel instance**
        Connection = nil,  -- Stores the connection object for cleanup
        hasTeleported = false, -- Debounce flag
        -- UI configuration
        UIName = "FashionFrenzyTimerDisplay",
        -- Position adjusted for 3 timers + close button
        Position = UDim2.new(0.5, 0, 0.30, 0), 
    },
    Hauntlet = {
        -- Path: Workspace.Interiors["MainMap!Fall"].HauntletMinigameJoinZone.Billboard.BillboardGui.TimerLabel
        TimerPathParts = {'Interiors', 'MainMap!Fall', 'HauntletMinigameJoinZone', 'Billboard', 'BillboardGui', 'TimerLabel'},
        -- Path: Workspace.Interiors["MainMap!Fall"].HauntletMinigameJoinZone.Ring
        DestPathParts = {'Interiors', 'MainMap!Fall', 'HauntletMinigameJoinZone', 'Ring'},
        -- Runtime References
        TimerObject = nil, -- **NEW: Stores the current TextLabel instance**
        Connection = nil,  -- Stores the connection object for cleanup
        hasTeleported = false, -- Debounce flag
        -- UI configuration
        UIName = "HauntletTimerDisplay",
        -- Position adjusted for 3 timers + close button
        Position = UDim2.new(0.5, 0, 0.35, 0),
    },
    -- *** NEW MINIGAME ADDED HERE ***
    SleepOrTreat = {
        -- Path: Workspace.Interiors["MainMap!Fall"].SleepOrTreatJoinZone.Billboard.BillboardGui.TimerLabel
        TimerPathParts = {'Interiors', 'MainMap!Fall', 'SleepOrTreatJoinZone', 'Billboard', 'BillboardGui', 'TimerLabel'},
        -- Path: Workspace.Interiors["MainMap!Fall"].SleepOrTreatJoinZone.Ring
        DestPathParts = {'Interiors', 'MainMap!Fall', 'SleepOrTreatJoinZone', 'Ring'},
        -- Runtime References
        TimerObject = nil,
        Connection = nil,
        hasTeleported = false,
        -- UI configuration
        UIName = "SleepOrTreatTimerDisplay",
        -- Position adjusted for 3 timers + close button
        Position = UDim2.new(0.5, 0, 0.40, 0),
    }
}

-- Position for the Close Button (adjusted position for rotation)
local CLOSE_BUTTON_POSITION = UDim2.new(0.5, 170, 0.33, 0) 

-- Position for the Title Label
local TITLE_LABEL_POSITION = UDim2.new(0.5, 0, 0.25, 0)

-- Default and Warning colors
local DEFAULT_COLOR = Color3.new(0.9, 0.9, 0.9) -- Off-white/Light Gray
local ALERT_COLOR = Color3.new(1, 0.2, 0.2)    -- Bright Red

-- Store the main ScreenGui reference globally for easy destruction
local ScreenGuiRef = nil

-- Utility function to safely find deep nested objects, waiting up to 10 seconds for each part
local function safeFind(pathParts) -- Takes an array of strings (object names)
    local current = Workspace
    local currentPath = "Workspace"

    for _, partName in ipairs(pathParts) do
        print("[Path Check] Currently looking for: '" .. partName .. "' inside of '" .. current.Name .. "'")
        
        -- Wait up to 10 seconds for the next part of the path to exist
        local foundPart = current:WaitForChild(partName, 10)
        currentPath = currentPath .. "['" .. partName .. "']"
        
        if not foundPart then
            warn("[Path ERROR] Failed to find: '" .. partName .. "'. (Full path: " .. currentPath .. ")")
            return nil
        end
        current = foundPart
    end
    print("[Path Success] Found object: " .. currentPath)
    return current
end

-- Teleport function with retry logic
local function teleportPlayer(destinationPart)
    local wasSuccessful = false
    -- Try up to 3 times with a short wait, in case the character is being reset/respawned
    for i = 1, 3 do
        local Character = LocalPlayer.Character
        
        -- 1. Check if the character exists
        if not Character then 
            warn(string.format("[Teleport Fail %d/3] Character not found. Waiting 0.5s...", i))
            task.wait(0.5)
            continue
        end

        local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
        -- 2. Check if the HRP exists (essential for CFrame manipulation)
        if not HumanoidRootPart then 
            warn(string.format("[Teleport Fail %d/3] HumanoidRootPart not found. Waiting 0.5s...", i))
            task.wait(0.5)
            continue
        end

        -- Success: Move the character slightly above the destination part
        local destinationCFrame = destinationPart.CFrame * CFrame.new(0, 5, 0) 
        HumanoidRootPart.CFrame = destinationCFrame
        print("[Teleport Success] Teleported to " .. destinationPart.Name)
        wasSuccessful = true
        break -- Teleport succeeded, exit the retry loop
    end

    if not wasSuccessful then
        warn("[Teleport Fail FINAL] Failed to teleport after multiple attempts.")
    end
end

-- Function to handle cleanup and stopping the script
local function stopMonitor()
    print("[Stop Monitor] Disconnecting all timer events and cleaning up UI.")
    
    -- Disconnect all connections stored in CONFIG
    for name, paths in pairs(CONFIG) do
        if paths.Connection then
            paths.Connection:Disconnect()
            paths.Connection = nil
            print("  - Disconnected " .. name .. " monitor.")
        end
    end

    -- Destroy the UI (will destroy the ScreenGui and everything inside it)
    if ScreenGuiRef and ScreenGuiRef.Parent then
        ScreenGuiRef:Destroy()
        ScreenGuiRef = nil
        print("  - Destroyed MinigameTimerUI.")
    end
end

-- UI Setup Function (Creates the ScreenGui, Title, and Close button ONCE)
local function ensureScreenGuiAndCloseButton()
    local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
    
    -- 1. Setup ScreenGui 
    local ScreenGui = PlayerGui:FindFirstChild("MinigameTimerUI")
    if not ScreenGui then
        ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "MinigameTimerUI"
        ScreenGui.Parent = PlayerGui
        ScreenGui.DisplayOrder = 100 -- Ensure it's on top of game UI
        ScreenGuiRef = ScreenGui -- Set the global reference
    end

    -- 2. Create the Title Label
    local TitleLabel = ScreenGui:FindFirstChild("TitleLabel")
    if not TitleLabel then
        TitleLabel = Instance.new("TextLabel")
        TitleLabel.Name = "TitleLabel"
        TitleLabel.Size = UDim2.new(0, 300, 0, 24)
        TitleLabel.Position = TITLE_LABEL_POSITION
        TitleLabel.AnchorPoint = Vector2.new(0.5, 0)
        TitleLabel.Font = Enum.Font.SourceSansBold
        TitleLabel.TextSize = 20
        TitleLabel.TextColor3 = Color3.new(1, 1, 1)
        TitleLabel.BackgroundColor3 = Color3.new(0.1, 0.1, 0.1)
        TitleLabel.BackgroundTransparency = 0.8
        TitleLabel.Text = "JOIN ZONE DETECTION MONITOR" -- NEW TITLE
        TitleLabel.Parent = ScreenGui
        TitleLabel.ZIndex = 2
        
        local UICorner = Instance.new("UICorner")
        UICorner.CornerRadius = UDim.new(0, 6)
        UICorner.Parent = TitleLabel
    end
    
    -- 3. Create the Close Button (if it doesn't exist)
    local CloseButton = ScreenGui:FindFirstChild("CloseMonitorButton")
    if not CloseButton then
        CloseButton = Instance.new("TextButton")
        CloseButton.Name = "CloseMonitorButton"
        -- SWAPPED SIZE: 24 (height) by 80 (width)
        CloseButton.Size = UDim2.new(0, 24, 0, 80)
        CloseButton.Position = CLOSE_BUTTON_POSITION 
        CloseButton.AnchorPoint = Vector2.new(0.5, 0)
        CloseButton.Text = "STOP" -- FIXED TEXT
        CloseButton.Font = Enum.Font.SourceSansBold
        CloseButton.TextSize = 18 -- Increased size slightly
        CloseButton.TextColor3 = Color3.new(1, 1, 1)
        CloseButton.BackgroundColor3 = Color3.new(0.9, 0.2, 0.2)
        CloseButton.BorderSizePixel = 0
        CloseButton.Parent = ScreenGui
        CloseButton.ZIndex = 3
        CloseButton.Rotation = 90 -- ADDED ROTATION
        
        -- Add a corner for a modern look
        local UICorner = Instance.new("UICorner")
        UICorner.CornerRadius = UDim.new(0, 6)
        UICorner.Parent = CloseButton
        
        CloseButton.MouseButton1Click:Connect(stopMonitor)
    end

    return ScreenGui
end

-- Function to create the individual TextLabel for a timer
local function createTimerLabel(configName, position)
    local ScreenGui = ensureScreenGuiAndCloseButton()
    
    local TimerDisplay = ScreenGui:FindFirstChild(configName)
    
    if not TimerDisplay then
        TimerDisplay = Instance.new("TextLabel")
        TimerDisplay.Name = configName
        TimerDisplay.Size = UDim2.new(0, 200, 0, 24) 
        TimerDisplay.Position = position
        TimerDisplay.AnchorPoint = Vector2.new(0.5, 0)
        TimerDisplay.Font = Enum.Font.SourceSansBold
        TimerDisplay.TextSize = 18
        TimerDisplay.TextColor3 = DEFAULT_COLOR
        TimerDisplay.BackgroundColor3 = Color3.new(0.1, 0.1, 0.1)
        TimerDisplay.BackgroundTransparency = 0.6
        TimerDisplay.BorderSizePixel = 0
        TimerDisplay.Parent = ScreenGui
        TimerDisplay.ZIndex = 2
        TimerDisplay.TextXAlignment = Enum.TextXAlignment.Center 
        
        local UICorner = Instance.new("UICorner")
        UICorner.CornerRadius = UDim.new(0, 6)
        UICorner.Parent = TimerDisplay
        TimerDisplay.TextStrokeTransparency = 0.8
    end

    TimerDisplay.Text = configName .. " Timer: Waiting..."
    
    return TimerDisplay
end

-- The persistent monitoring loop (replaces setupMinigameMonitor)
local function startMonitorLoop(configName, paths)
    local uiDisplay = createTimerLabel(paths.UIName, paths.Position)
    local destinationPart = nil -- Must be found before connecting

    -- Define the monitoring logic once
    local function checkTimer(newText)
        -- Check if we still have a valid destinationPart (should always be true here)
        if not destinationPart or not destinationPart.Parent then
            warn(string.format("[Monitor Error] Destination part for %s lost! Disconnecting monitor.", configName))
            paths.Connection:Disconnect()
            paths.Connection = nil -- Force a reconnect attempt
            paths.TimerObject = nil
            return
        end

        local rawText = newText or paths.TimerObject.Text
        local text = rawText:gsub("[\r\n]", "")
        
        print("[Text Update] " .. configName .. " timer text changed to: '" .. text .. "'")

        local target30 = "00:30"
        local target20 = "00:20"
        
        local isAlertTime = string.find(text, target30, 1, true) or string.find(text, target20, 1, true)

        -- UI Update
        uiDisplay.Text = configName .. ": " .. text 

        if isAlertTime then
            if not paths.hasTeleported then
                paths.hasTeleported = true 
                uiDisplay.TextColor3 = ALERT_COLOR 
                print("ALERT: " .. configName .. " is at target time. Teleporting.")
                teleportPlayer(destinationPart)
            end
        else
            paths.hasTeleported = false
            uiDisplay.TextColor3 = DEFAULT_COLOR
        end
    end

    -- Persistent monitoring loop
    while true do
        task.wait(0.5) -- Small wait to prevent crashing the thread

        local shouldAttemptSetup = false

        if paths.Connection and paths.TimerObject and paths.TimerObject.Parent then
            -- Connection is active and object is valid. Wait longer before next check.
            task.wait(2)
            continue
        else
            -- Connection is broken or object is gone. Attempt setup.
            shouldAttemptSetup = true
        end

        if shouldAttemptSetup then
            print(string.format("[Monitor Reconnect] %s monitor connection lost/inactive. Attempting reconnection...", configName))
            uiDisplay.Text = configName .. ": [Attempting Reconnect...]"
            uiDisplay.TextColor3 = DEFAULT_COLOR

            -- 1. Safely find the TimerLabel (source)
            paths.TimerObject = safeFind(paths.TimerPathParts)
            
            if not paths.TimerObject or not paths.TimerObject:IsA("TextLabel") then
                warn(string.format("[Reconnect Fail] Failed to find TextLabel for %s. Retrying in 5s.", configName))
                uiDisplay.Text = configName .. " Timer: [ERROR - Path Failed, Retrying...]"
                task.wait(5)
                continue
            end
            
            -- 2. Safely find the Destination Part (Only needs to happen once but checked here for robustness)
            if not destinationPart or not destinationPart.Parent then
                destinationPart = safeFind(paths.DestPathParts)
                if not destinationPart or not destinationPart:IsA("BasePart") then
                    warn(string.format("[Reconnect Fail] Failed to find Destination Part for %s. Retrying in 5s.", configName))
                    uiDisplay.Text = configName .. " Timer: [ERROR - Destination Failed, Retrying...]"
                    task.wait(5)
                    continue
                end
            end
            
            -- If we reach here, we have both a valid TimerObject and DestinationPart
            
            -- 3. Disconnect any old connections (safety check)
            if paths.Connection then
                paths.Connection:Disconnect()
            end

            -- 4. Connect the check to the Text property change event and store the new connection
            paths.Connection = paths.TimerObject:GetPropertyChangedSignal("Text"):Connect(checkTimer)
            
            print(string.format("[Monitor Active] Successfully reconnected monitor for %s.", configName))

            -- Run once immediately to set the initial UI state
            checkTimer(paths.TimerObject.Text)
        end
    end
end

-- NEW STARTUP SEQUENCE: Start persistent monitor tasks.
print("[Setup] Starting persistent monitor tasks...")

-- Run persistent monitor for all configured minigames
for name, paths in pairs(CONFIG) do
    -- task.spawn ensures monitors run concurrently
    task.spawn(startMonitorLoop, name, paths) 
end
